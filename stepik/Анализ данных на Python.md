## Библиотека (модуль/либа/пакет)

Библиотека – набор кода, посвящённый определённой цели (например, математические функции, работа в интернете, обработка текстов). Используется, чтобы облегчить работу, связанную с этой целью. В нашем курсе самый простой пример – библиотека `pandas`, которая применяется для анализа данных.

По умолчанию содержимое библиотек недоступно при работе в python. Чтобы их использовать, необходимо их сначала импортировать:

```python
import pandas as pd
```

- `import` – ключевое слово, дающее питону понять, что мы собираемся импортировать библиотеку
- `pandas` – название библиотеки
- `as` – ключевое слово, означающее, что дальше будет использоваться другое название библиотеки
- `pd` – то, какое название мы решили использовать в коде вместо названия этой библиотеки (её элиас, alias); названия произвольны и обычно конвенциональны (в дальнейшем мы будем использовать название `pd`)
## Считывание csv

```python
pd.read_csv('path_to_your.csv')  # read_excel for reading excel files
```

Считывает csv файл, который лежит по указанному в скобках пути. На Windows пути к файлам содержат символ `\`, который является специальным символом в строках во многих языках программирования, включая Python. Поэтому необходимо сделать следующее – либо удвоить все `\` в строке, содержащей путь, либо поставить `r` перед строкой:

- путь на Windows – `C:\user\docs\Letter.txt`
- строка, содержащая путь – `'C:\user\docs\Letter.txt'`
- также допустимые варианты –`'C:\\user\\docs\\Letter.txt'` или `r'C:\user\docs\Letter.txt'`

На сервере мы работаем с Unix путями, например `/home/user/letter.txt`. С ними таких проблем не возникает – достаточно поместить путь в кавычки, чтобы всё было хорошо.

### Дополнительные аргументы функции read_csv

Аргументы (или параметры) – это настройки, которые мы можем задать для функции.

- **encoding** – параметр в `read_csv`, отвечает за кодировку текста, которая может быть различной. Самая распространённая – utf-8. Пример указания кодировки: 
    

```python
pd.read_csv('path_to_your.csv', encoding='Windows-1251')  # now you are reading file encoded with Windows-1251
```

- **sep** – разделитель между ячейками в строке (по умолчанию `,`)
    

```python
pd.read_csv('path_to_your.csv', encoding='Windows-1251', sep=';')  # now you additionally specified that fields are separated with ;
```

- **parse_dates** – указывает, стоит ли воспринимать даты как даты (по умолчанию они воспринимаются пандасом как строки).  
    Параметр с датами может принимать несколько значений:
    
    - `True` – пытается перевести в дату первую колонку
    - список колонок – пытается перевести в дату указанные в списке колонки

```python
# And create_data, payment_data columns will be treated as data
pd.read_csv('path_to_your.csv', encoding='Windows-1251', sep=';', parse_dates=['create_data', 'payment_data'])
```
```python
import pandas as pd
df = pd.read_csv("C:\Users\HuaweiNB421\Машинное обучение\lesson_1_data.csv", encoding='windows-1251', sep=';')
```
![[Pasted image 20240218172920.png]]
## Атрибуты vs Методы

У объектов есть и методы, и атрибуты. В чём же их различие? Прежде всего они отличаются внешним видом: после названия метода идут скобки, в которых могут быть аргументы, а после названия атрибута скобок нет.

Методы являются функциями, связанными с объектом. То есть они что-то вычисляют, сохраняют или загружают.

Атрибуты – сохранённые признаки, связанные с объектом. Их значение сохранено и не вычисляется при вызове.

Пример с методом `head()` и атрибутом `shape`
`shape` – атрибут, хранящий данные о размерах таблицы. Возвращает кортеж (для простоты воспринимайте его как неизменяемый список). В случае датафрэйма кортеж содержит два значения – число строк и число колонок в нём.
![[Pasted image 20240218173123.png]]
## Типы колонок

Чтобы узнать типы колонок в вашем датафрэйме, воспользуйтесь атрибутом `dtypes` – он возвращает серию с описанием типа каждой колонки. Типы более-менее совпадают с типами в python, однако есть и различия:

- здесь у типов присутствует описание размера (числа битов)
- все сложные типы (не числа или логические значения) отображаются как `object`

Информация о типе важна для дальнейшей работы с датафрэймом (например, чтобы не произвести сложение строк, думая, что это числа).
## Метод describe

`describe` – удобный метод для вывода описания числовых колонок в датафрэйме:
`describe` выводит информацию о числе строк, среднем значении, стандартном отклонении, минимуме, максимуме и значениях 25-го, 50-го и 75-го квартилей. Он действует только на числах, так как большинство этих параметров неочевидно определяются для других типов данных (например, строк).
![[Pasted image 20240218175636.png]]

## Переименование колонок

В идеале названия колонок осмысленны, актуальны, не содержат пробелов и на английском языке. Конечно, для каких-то задач, они могут быть и с пробелами, и на другом языке. В любом случае, если вы хотите их переименовать, для этого есть метод `rename`. Пример переименования колонки _x_ в _name_, а колонки _y_ в _salary_:

```python
# Rename columns
df = df.rename(columns={'x': 'name', 'y': 'salary'})
```

А вот пример переименования лэйблов строк из _0_ в _Ivanov_ и из _1_ в _Vasilev_:

```python
# Rename index (row names)
df = df.rename(index={0: 'Ivanov', 1: 'Vasilev'})
```

Один из способов переименования – передать словарь, в котором ключами являются старые названия, а значениями – новые.
## Обращение к колонкам

В пандасе существует множество способов обратиться к колонке датафрэйма. Самый удобный: 

```python
df.column_name
```

- `df` – датафрэйм
- `column_name` – название колонки

Чтобы это работало, название колонки должно состоять из одного компонента (например, слова), и не должно совпадать с названием методов датафрэйма (имя колонки `count` не сработает). Для языковой однородности – ещё и на английском, но это не является обязательным.

Но что делать, если название колонки состоит из двух слов? В таком случае необходимо либо переименовать колонку, либо использовать другой способ доступа:

```python
df['column name']
```

Работает для всех случаев кроме тех, когда в названии присутствуют одинарные кавычки. Тогда либо используйте вокруг названия двойные, либо поставьте `\` перед кавычками внутри. Лучше называть колонки без кавычек.

Для получения нескольких колонок передайте внутрь квадратных скобок список с именами желаемых колонок:

```python
df[['column1', 'column2', 'column3']]
```

[Документация](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)

## Создание колонки

Делается так же просто, как и задание нового значения в словаре :)

```python
# Create new column in the df with name new_column which is equal to 5 in each cell
df['new_column'] = 5
```

![[Pasted image 20240218175733.png]]
## Применение вычислительных методов

Существует набор методов, доступных для колонок датафрэймов. Например, есть колонка `money` в датафрэйме, содержащая полученные объёмы денег. Применив метод `sum`, можно посчитать их сумму.

```python
df.money.sum()
69120
```

Ещё несколько примеров:

- `product` – перемножение
- `std` – среднеквадратичное отклонение
- `var` – дисперсия
## Цепочка методов (method chaining)

Приём для объединения нескольких действий в одно. Большинство методов датафрэймов возвращают вам результат, который довольно часто тоже является датафрэймом. Следовательно, от него тоже можно вызвать метод.

Стандартная запись:

```python
df = df.query('income >=  1000')
df = df.groupby(['title', 'status'], as_index=False).agg({'income': 'sum', 'id': 'count'})  # groupby is usually immediately followed by agg
df = df.sort_values(['title', 'status'])
```

Сокращённая запись:

```python
df  = df.query('income >=  1000').groupby(['title', 'status'], as_index=False).agg({'income': 'sum', 'id': 'count'}).sort_values(['title', 'status'])
```

Как можно заметить, эта запись довольно длинная и не очень удобная для чтения. Обычно, такая цепочка оформляется в блок, где каждый метод идёт на своей строке. Есть два варианта оформления, какой из них выбрать – вопрос предпочтения и конвенции в вашей организации:

```python
# \ after each nonfinal line to demarcate line continuation for python
df  = df.query('income >=  1000') \
  .groupby(['title', 'status'], as_index=False) \ 
  .agg({'income': 'sum', 'id': 'count'}) \ 
  .sort_values(['title', 'status'])
```

```python
# Parentheses around the whole expression for the same purpose as backslash in previous example

df  = (df.query('income >=  1000')
         .groupby(['title', 'status'], as_index=False)
         .agg({'income': 'sum', 'id': 'count'})
         .sort_values(['title', 'status']))
```
## Группировка

Часто используемый приём для вычисления чего-либо по данным. Осуществляется с помощью метода `groupby` – группирует данные в датафрэйме по указанным колонкам:
Применение одного метода `groupby` не даёт видимого эффекта, хотя на самом деле все строки были объединены в группы по значению в колонке `company`: с одним значением в одну группу, с другим – в другую. `groupby` обычно используется не сам по себе, а в связке с `agg` или другим методом. Можно использовать несколько колонок для группировки, передав их в виде списка.
### Дополнительные параметры

`as_index` – принимает `True` или `False` для обозначения того, нужно ли использовать переданные для группировки колонки в качестве индекса, по умолчанию `True`
## Агрегация

`agg` – функция для агрегирования данных, применяется после группировки методом `groupby`

В `agg` указывается, на каких колонках какие действия необходимо произвести:

![](https://lh4.googleusercontent.com/_p2cpYXmJwdbYbV1SCcsMLUuxqTwvoRkDiQpClNpZKZX216SKMonkk_T_i_CsdvGI2VDUWrWWBmDihY3Quav-D5rBDVFgjvp49C-8e2J9ek8sLrfysOPwMWnZMkvPAKmGgmWW1Eh)

Существуют разные способы передать в `agg` что и как вы хотите агрегировать. Самый простой и полный – использовать словарь, в котором ключами являются названия колонок, а значениями – применяемые к ним функции. Чтобы применить несколько функций, используйте список функций. Можно передать как сами функции (`sum`), так и обозначающие их строки (`'sum'`).

В результате агрегации из массива значений (колонка) получается одно значение на каждую агрегирующую функцию.
## Сортировка значений

Для такой сортировки используется метод `sort_values`, принимающий колонку или список колонок, по которым будет идти сортировка (обратите внимание: заглавные буквы считаются меньше обычныx):

![](https://lh5.googleusercontent.com/9jD_PUSCPNVzFMHmWa2bglfemLc0qFVW_48f1sv7X7U5DuKONZASFnKZIZhik3Lw_EUPsBT4ItaML253s8rQoq7Ns0OS89NvQCfDjdJELR-fJqPjSjjE1CM6EZx5-Y4LM0UssFvQ)

### Дополнительные параметры

`ascending` – принимает логическое значение, которое показывает, сортировать ли колонку по возрастанию.

## value_counts

Метод, который считает, сколько раз встречается каждое уникальное значение переменной. Например, имеется следующий набор данных:
Посчитать, сколько раз встречается каждое имя (`name`), можно с помощью следующей команды:

```python
df['name'].value_counts()
```

Результат возвращается в формате pd.Series (серии) :

```no-highlight
Persik    2
Tolya     1
Barsik    1
Name: name, dtype: int64
```

Также метод `value_counts` принимает на вход несколько **параметров**:

- `normalize` – показать относительные частоты уникальных значений (по умолчанию равен `False`). 
- `dropna` – не включать количество NaN (по умолчанию равен `True`)
- `bins` – сгруппировать количественную переменную (например, разбить возраст на возрастные группы); для использования данного параметра необходимо указать, на сколько групп разбить переменную

Несколько примеров:

1) Получаем частоту встречаемости (напр. Persik – в 40% наблюдений),  также не удаляем из результата NaN:

```python
df['name'].value_counts(normalize=True, dropna=False)
```

```no-highlight
Persik    0.4
Tolya     0.2
Barsik    0.2
NaN       0.2
Name: name, dtype: float64
```

2) Разбиваем `year` на 2 промежутка:

```python
df['year'].value_counts(bins=2)
```

```no-highlight
(2017.5, 2020.0]      3
(2014.994, 2017.5]    2
Name: year, dtype: int64
```
## Запросы

В пандасе есть возможность фильтровать данные, используя SQL-like синтаксис. Для этого применяется метод `query`, принимающий строку с запросом. Внутри него можно использовать названия колонок (если они без пробелов). При использовании строк внутри запроса экранируйте кавычки с помощью `\` или используйте другую пару.

![](https://lh5.googleusercontent.com/AJcUyvZrHXdCRD45OC2SXebiaYabtWm1JWNqCieDUtKV0ILkMava-cstwoLPXFOL8tySPgYnKOTsw8nt3CW5s5KwP8RiJTRHXr0IMqE_28CPk0SZsCipuFgZ3Onn-1mEoowaXJ-1)

В `query` также можно передать сразу несколько условий. Условия, которые должны выполняться одновременно, соединяются с помощью `and` или `&`: 

```python
product_data.query("title == 'Курс обучения «Эксперт»' and status == 'Завершен'")
```

Когда должно удовлетворяться одно из условий – `or` или `|`:

```python
product_data.query("title == 'Курс обучения «Эксперт»' or status == 'Завершен'")
```
## Запись в файл

Датафрэйм можно записать в различный формат. Пожалуй, самый распространённый – csv. Для записи в этот формат необходимо применить к датафрэйму метод `to_csv` и передать в него путь, по которому вы хотите создать файл.

```python
df.to_csv('my.csv')
```

### Дополнительные параметры

- `index` – записать индекс датафрэйма в csv как первую колонку
- `sep` – используемый при записи разделитель колонок
## Использованные в уроке функции

- `replace` – применяется к строкам, принимает две строки: что заменить и на что заменить  
    ![](https://lh6.googleusercontent.com/g0ZUk3swPL3auJrFFaTHgVuFDLtvjHYeay1SPVhCgzYJwdd8SW4o7Ovwxv8M7zDzR84_XULVJqRuzVKwrgp4cJ4SpA9iAbKmAB8ZjMPQZOyRCRRXju739RJGkPldUuj9UrMDaG1T)  

- `strip` – применяется к строкам, по умолчанию убирает пробелы слева и справа  
    ![](https://lh4.googleusercontent.com/sy9A_NuKwAugPR1ZkIikbSUXTmLq_fLouPuwTSgjyKz83pXGju4yk-3lp1m1cv3QsiUUtNCN8rSLm7ubE8UiLLDyROY8xhBH5k8gzBRcLMQNMlbwcdzKN5mncau7W5dsBYQpbw8W)  
- `round` – применяется к дробным числам, округляет их, можно передать дополнительный аргумент, который означает число знаков после запятой  
    ![](https://lh4.googleusercontent.com/azsSotd98aezT8-iDPm3fY6v2Y6gq6kKzvXJNfp7UVpxjN4RjaExunpUKsKHRPZxYEqRv8N8y4fm1s85SHN4mhZxEVQah0SSkpWVN_hTEZ516Qhz0HCDDQowfxNQrxNGkGA-wIbQ)
    ## Векторизация

Векторизация – это специальная техника, позволяющая в пандасе быстро выполнять в одну строчку операции, которые в чистом питоне требуют как минимум одного цикла. Быстрота связана с тем, что код пандаса реализован на более быстром чем питон языке, а в питоне просто представлены функции. Благодаря векторизации, мы можем делать различные операции со всеми колонками целиком, не отвлекаясь на итерирование по элементам.

![](https://ucarecdn.com/018eb4a1-1e8b-408d-b7a8-6a3a612b2574/)

Умножим каждый элемент на 3:

![](https://ucarecdn.com/9bb68d91-784b-494d-8fc9-7d55d1a97f8f/)

Или выясним для каждого значения, больше ли оно чем 3:

![](https://ucarecdn.com/5a662319-feb0-4479-a5df-13569469e856/)

## None

`None` – это специальный тип данных в питоне, который имеет только одно одноимённое значение – `None`. Используется в тех случаях, когда нужно обозначить ничто. Обычно (но совсем не обязательно) его возвращают функции, которые как-то изменяют данные:

```python
xs = [1, 2, 3]
a = xs.append(4)

print(xs)
[1, 2, 3, 4]

print(a)
None
```

Толку от присвоения выше (`a = xs.append(4)`) нет, просто постепенно запоминайте такие функции, и не перезаписывайте ваши данные вызовами типа:

```python
xs = xs.append(4)
```
## Свои функции

Служат для переиспользования кода. Допустим, вы написали изумительный скрипт, который решает 20% вашей работы. Теперь вам нужно использовать его каждый день на новых данных. Чтобы это упростить, существуют функции. Они позволяют свести весь код к одной строке и менять название поступающих файлов и других параметров только в одном месте.

### Задавание функций

```python
def function(parameter):
   what to do
```

- `def` – ключевое слово, даёт питону понять, что дальше будет задана функция
- `function` – название, которое мы выбрали
- `parameter` – инпут функции, т.е. какие данные ей нужны для работы. Параметров может быть 0 (без инпута) или больше. Это может быть почти что угодно:
    - путь к файлу
    - название папки
    - число строк, с которыми нужно работать
    - путь к отчёту, который будет создан
- `what to do` – тело функции, функционал, который будет работать

По умолчанию при завершении своей работы функция ничего не вернёт обратно (например, в отличие от метода `head` у датафрэйма). Чтобы она возвращала значение после вызова, в тело функции необходимо добавить ключевое слово `return` перед переменной, которую вы хотите вернуть:

```python
# 2 simple functions
# Without return
def print_a(a, b):
    print(a)

# With return
def return_a(a, b):
    return a

x = print_a(3, 5)  # x is None
3

y = return_a(3, 5)  # y is 3
```
## Время

Для работы с датой и временем можно использовать модуль `datetime`. Для получения данных о времени в момент вызова функции используйте функцию `today` в одноимённом подмодуле:

```python
import datetime  # by convention imports are placed in the head of file and separated with 2 blank lines from other code


date = datetime.datetime.today()
```

Само по себе это даст вам специальный тип даты. Чтобы перевести его в строку сделайте следующее:

![](https://lh6.googleusercontent.com/VYSDhAWhzNCWFpgCUOtjdd_PfOtBVbPdRz7QbWtawTbyEb48IvZfYB9bOEu4sHB9ajucUxbIL6xBwb12JU6Zai3CRsILvA0tOTm9p0sBtarj-nuzUXJZqM--CLUBB-gyBnWFqdkX)

Метод `strftime` форматирует дату в соответствии с переданным в него форматом:

- % – обозначает, что далее следует часть даты
- Y – год четырьмя знаками
- m – месяц двумя знаками
- d – день
- H – час
- M – минуты
- S – секунды

Можно использовать только часть фрагментов даты, разделители между ними – на ваше усмотрение (в примере это `-` и `:`). Несколько примеров:

```python
from datetime import datetime


# current date and time
now = datetime.now() 
print(f'Full time format of now is {now}')
Full time format of now is 2020-06-01 17:54:40.010540
```

```python
# Year
year = now.strftime("%Y")
print("year:", year)
year: 2020
```

```python
# Month
month = now.strftime("%m")
print("month:", month)
month: 06
```

```python
# Day
day = now.strftime("%d")
print("day:", day)
day: 01
```

```python
# Time
time = now.strftime("%H:%M:%S")
print("time:", time)
time: 17:54:40
```

```python
# Date and time
date_time = now.strftime("%m/%d/%Y, %H:%M:%S")
print("date and time:",date_time)
date and time: 06/04/2020, 17:54:40
```

**Сортировка по сумме денег:**
![[Pasted image 20240218181622.png]]
![[Pasted image 20240218182955.png]]


![[Pasted image 20240218184254.png]]


**Предподготовка данных:**

`unique` – метод, возвращающий уникальные значения в колонке.
`unique` – метод, возвращающий уникальные значения в колонке.
Чтобы посчитать медиану колонки, используйте метод `median`
Для расчёта среднего значения используйте метод `mean`
`split` – метод, который разбивает строку на куски и помещает фрагменты в список. По умолчанию делит по пустым символам (пробел, табы, перенос строки).
## Анонимные функции

Обычно используются, когда нужно куда-то быстро поместить нечасто используемый функционал. Если вы планируете использовать анонимную функцию больше одного раза, лучше напишите обычную функцию :)

```python
lambda x: do something
```

- `labmda` – ключевое слово, задающее анонимную функцию (не имеющую имени)
- `x` – то, как мы назвали аргумент, принимаемый функцией
- `:` – разделяет заголовок и тело безымянной функции
- `do something` – тело функции, должно помещаться в одну строчку, будет автоматически возвращаться без return

```python
# Take 1 argument and add 3 to it
lambda x: x + 3
```

Один из примеров использования лямбда-функции – переименование колонок в датафрэйме. Здесь мы делаем их заглавными и заменяем дефисы на нижние подчёркивания.

```python
# df is a dataframe as usual
df = df.rename(columns=lambda c: c.upper().replace('-', '_'))
```
## Серии

`pd.Series` – более примитивный тип данных в `pandas`, соответствует колонке датафрэйма. В ней хранятся данные одного типа (числа, строки и т.п.). Работая с колонкой, мы работаем именно с серией. Часть методов и атрибутов серии и датафрэйма совпадают.
## Применение функций к датафрэйму

`apply` – применяет переданную в него функцию ко всем колонкам вызванного датафрэйма. Чтобы применить функцию к одной колонке датафрэйма, можно выбрать её перед применением `apply`, например:

![](https://lh3.googleusercontent.com/K2QUILHL4joOjfDQtGWt29T45lKeRlmKuW7VPxgLuj6CFapTwvF9EKsT_IT70_jpHIvpfH8it7IdF5b2YgNjoH11G-_Iz5QELvX2eLALZ42dQP_GSnsiRVZXeq7Oy64msWPKZm4x)

## Объединение датафрэймов

Зачастую называется джойном. Очень частая операция, которую можно сделать с помощью нескольких функций. Одна из них – `merge`. Обязательным аргументом является другой датафрэйм, с которым планируется объединение. Объединение идёт по общей колонке, у которой имеется одинаковый смысл и общие значения в обоих датафрэймах. Существуют различные типы джойнов, они будут рассмотрены в курсе по SQL. Пожалуй, самый частый из них – inner.

Здесь мы объединяем датафрэйм `users_data` с датафрэймом `users_lovely_brand_data` по колонке `tc` с помощью inner джойна:

![](https://lh6.googleusercontent.com/5hbeYJikHDYobX_LBQeoJrh79I4TnQodNdF0dfut3kEA73huEAhJ5Rff3iS0CSTHLEV2-l8jRZ-QH-TaJ2MDXMGtQz96So-vDlRG8VjgDEm3vS7akWcxqAvzfOQnmWAFSYnyd5lz)

В результате получается один датафрэйм, в котором колонки из двух таблиц, относящиеся к одному наблюдению, объединяются в строку. Звучит сложно, поэтому для практики стоит попробовать сделать несколько простых джойнов :)

### Дополнительные аргументы функции merge

- `how` – как объединять датафрэймы, возможные варианты: inner, outer, left, right
- `on` – общая колонка, по которой будет происходить объединение
## Индекс и имена колонок

Индекс – это лэйбл строки в таблице, по умолчанию является её номером. А имена колонок... это имена колонок, то есть лэйблы, по которым мы можем обращаться к каждому из столбцов.

У датафрэйма есть два атрибута – `index` и `columns`.  Они позволяют получить доступ к соответствующей информации в виде array (на самом деле не совсем array).

![](https://ucarecdn.com/c627a31f-4ccf-4f68-8067-f0b13704b3b2/)

```python
df.index
Index(['easy', 'executive', 'group'], dtype='object')
```

```python
df.columns
Index(['journey_id', 'driver_id'], dtype='object')
```

## Сброс индекса

Иногда вам может потребоваться перевести индекс датафрэйма в колонку. Для этого существует метод `reset_index`. Индексом становится дефолтная последовательность чисел от 0 до N-1, где N – число строк.

![](https://lh3.googleusercontent.com/A43QEmPUECYYUo8bGyzLMnV-jd1PY8a8nRqp_YUGMn6jZ9oC-b_Z1cbiVB1bSxjnc2vTitcfQWOYLuFdfdf8sqzWO4mbpmPXtGZAxsO8fPgGQtu7tjyBuoxXOQsvh4h4nOBlpgKN)

![](https://lh5.googleusercontent.com/G95Jkz_BIW2AfWEIjAdTI2OrqFmOvmf81GEFxF_cGdOEtouAshzIhLW305bZcMHembzIFdMG9tMN1_vmdpj40J_4jDBs10Djwx31p-6HsFCEKqInTSltZT5nc14iUnolzOuEEU0c)

### Удаление индекса

Аргумент `drop` отвечает за то, будет ли индекс переведён в колонку или же убран из таблицы:

![](https://lh6.googleusercontent.com/CqGpuTINjdEwk7EkRBq9Qrpc5Y0tTG5hRju3Y5byhhNR4B4o5_WIoOJmgM0Dci_GrixUjIH4r-0vUfm5mUnV5Zvcv2DHgsKVbdQ4MVmm4nq4l7e59K9DghuRnkcmd6TnEWn-TJdY)

## Поиск пустых значений

`isna` – это чудо-метод, с помощью которого можно быстро найти пропущенные значения в датафрэйме.

![](https://ucarecdn.com/2d689a8f-a0bf-439b-b692-0d31827f10a5/)

Применив его, на выходе мы получаем датафрэйм той же размерности, где в каждой ячейке будет стоять `True` или `False` в зависимости от того, было ли значение пропущено.

![](https://ucarecdn.com/a16ac0ed-5142-49b5-acd8-f371a8b9d09e/)

В связке с ним можно использовать, например, метод `sum`, чтобы посмотреть на число `NA` в разных колонках.

![](https://ucarecdn.com/9e3efc6d-817f-4fe3-ad01-c9a0e674a440/)

Графики – важная часть анализа данных, так как они наглядно представляют данные (если тип графика хорошо подобран) и позволяют быстро разобраться в их сути.

Чтобы графики отображались в юпитер ноутбуке, необходимо выполнить следующую строчку:

```python
%matplotlib inline
```

В Python существуют разные способы создания графиков. Популярные библиотеки для визуализации:

- `pandas`
- `seaborn`
- `matplotlib`

Самый простой способ визуализировать данные – вызвать метод `plot` у датафрэйма (или его колонки). Например, гистограмма значений в колонке `orders` :

![](https://lh4.googleusercontent.com/ddxvbkPBaWnAl2WzbRyOeCdCiUvIOKu3PKViooxBgs4MAZvtNzE6t1oSuWGHo0mew510Jk2-NGNZP-55L7jJpUwzywtz7g8EYtYQODm552WVvr6KDUJ7133cJlt0zHDRq-D3dUYW)

Другой вариант записи:

![](https://lh3.googleusercontent.com/34_BT6QtWrGHvDqlpIJ0O7PvS09BAkNekkBhnnoEkt2ZFy8hRN6SgaHhCs-PwRvlxfSlyQO2Zhfpzm53LdBhs9az7d4VMbnwA0kC_dmep7lB6by7znl6vpfPGfhM6hnXgrorNTC7)

Функции рисования имеют весьма большое количество параметров, используйте их при необходимости. Здесь `bins` – это число диапазонов (корзин или бакетов), на которые мы разделяем значения.

## seaborn

Продвинутая библиотека, позволяющая делать очень красивые графики. Согласно конвенции загружается следующим образом:

```python
import seaborn as sns
```

Ниже представлены примеры создания графиков с её помощью.

### Гистограмма

![](https://lh4.googleusercontent.com/o292kFU32Ir2xzx5mArEKhONaLm90Gdj7MVQEZwoRshzQeVm31YWVN5KeGPrzR-hIwQgRviSH3MeXLNqxCHbzPdFdPqSGazeeGpzsGrRf9do7l4aXiZPhD1dQhNQF-iQyWh7hJqH)

[Документация](https://seaborn.pydata.org/generated/seaborn.distplot.html)

### Боксплот

![](https://lh4.googleusercontent.com/mihytILMFpm5JQvuHDzlteKQXel6_4ozXq_6MFIJZbQWuK89hmS2eJKGMW_oaUoRu4kscDu328UcKF6cUCBRN7n0ZYrpi-d62n_ZahUfn6Rst6JfL-kukLwW1wyAVnouoO1fgZ04)

[Документация](https://seaborn.pydata.org/generated/seaborn.boxplot.html)

### Барплот

![](https://lh3.googleusercontent.com/ksgaF1eJVxJJmbTr7cZ2VJ7xhYEdXu8QO7J00cOWdK-z6TXuYz0Cq7IxcsuQ_jD-zqrHfv9O19P7KHgbgSzeFYW4ZNqZFrxQImui4kmmsqgUZwcED6lCx4Mu4lruZNS20oYM_7Sm)

На графиках перекрываются подписи. Скоро мы разберёмся, как это можно исправить.
## matplotlib

Базовая библиотека для рисования графиков в Python. На ней построены более продвинутые и простые в использовании библиотеки типа `seaborn`. Через `matplotlib` можно нарисовать что угодно, но часто на это уходит слишком много строк кода, и её в основном используют для тонкой настройки графиков и их сохранения.

Традиционно `matplotlib` импортируется следующим образом:

```python
import matplotlib.pyplot as plt
```

### Настройка графиков

Важный момент – большинство настроек должны быть написаны к каждому графику отдельно. Иными словами, настройки, написанные в ячейке с одним графиком, не будут применены к другому. 

#### Изменить размер

В `figure` в `figsize` подаётся кортеж (как список, только в круглых скобках) с масштабом графика формата `(ширина, высота)`

![](https://lh4.googleusercontent.com/xyD6F5yBRMt3hSLJebkchDMAmq39-3qgAj3-9917U6ZGF8o7s_9JWpHQdAeWHpSjgTNBAycQBecPWtCEXMiM84b4nB5E3rtvIT2baKa_7HFMoRVYypLGTltAwY0OpMN3LrBMB6jI)

[Больше информации](https://stackoverflow.com/questions/332289/how-do-you-change-the-size-of-figures-drawn-with-matplotlib)

#### Сохранение картинки

Сохранить график можно с помощью `savefig` , где аргумент – это путь к сохраняемой картинке (желаемое название и формат):

![](https://lh6.googleusercontent.com/eBsNbpX1qOBSNMfL-hzl5z0pL2k93lHgAT8BtZ9dBWsHyfqjscKRLPraOMH3WV2gmiTbJTv_vYstJeGpDBEAJ7kZLs1oqCf_jO-EGBmt5_21nUtBRQT980ca3wHLH_mOPf-Qsod-)

![[Pasted image 20240218225551.png]]
![[Pasted image 20240218225607.png]]

![[Pasted image 20240218225741.png]]
![[Pasted image 20240218230509.png]]
![[Pasted image 20240218231045.png]]


**Переходим к аналитике (разведовательный анализ)**

![[Pasted image 20240218231854.png]]
![[Pasted image 20240218232518.png]]
![[Pasted image 20240218232723.png]]
![[Pasted image 20240218232907.png]]
![[Pasted image 20240218233209.png]]
![[Pasted image 20240218234528.png]]
![[Pasted image 20240218234654.png]]
![[Pasted image 20240218235021.png]]
![[Pasted image 20240218235411.png]]
**Визуализация**
![[Pasted image 20240218235452.png]]
![[Pasted image 20240218235642.png]]



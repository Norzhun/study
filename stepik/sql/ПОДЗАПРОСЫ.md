
Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.

Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из следующих:

- одна строка и один столбец;
- нескольких строк с одним столбцом;
- нескольких строк с несколькими столбцами.

В зависимости от типа результирующего набора подзапроса определяются операторы, которые могут использоваться в основном запросе.

## Пример

Получим список всех бронирований самого дорогого на данный момент жилого помещения:

```sql
SELECT * FROM Reservations
    WHERE Reservations.room_id = (
        SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
    )
```

В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

```sql
SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
```

|id|
|---|
|21|

# Подзапрос с одной строкой с одним столбцом

## Примеры

Следующий простейший запрос демонстрирует вывод единственного значения (названия компании). В таком виде он не имеет большого смысла, однако ваши запросы могут быть намного сложнее.

```sql
SELECT (SELECT name FROM company LIMIT 1) AS company_name;
```

|company_name|
|---|
|Don_avia|

Таким же образом можно использовать скалярные подзапросы для фильтрации строк с помощью WHERE, используя операторы сравнения.
```sql
SELECT * FROM FamilyMembers
    WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
```

| member_id | status   | member_name      | birthday                 |
| --------- | -------- | ---------------- | ------------------------ |
| 8         | daughter | Wednesday Addams | 2005-01-13T00:00:00.000Z |

## Важность соответствия используемого оператора и результата подзапроса

При использовании результата подзапроса с операторами сравнения, как в нашем примере, важно, чтобы подзапрос возвращал именно скалярное значение (1 строка и 1 колонка).

Если бы данный подзапрос вернул несколько значений, то СУБД бы вернула ошибку, сообщающую, что ожидалось, что подзапрос вернёт лишь 1 запись: «ER_SUBQUERY_NO_1_ROW: Subquery returns more than 1 row».

Поэтому стоит быть осторожным при написании подзапросов и представлять, какой результат вернёт подзапрос, и какие операторы мы можем использовать вместе с результирующим набором.


Выведите всю информацию о пользователе из таблицы Users, кто является владельцем самого дорого жилья (таблица Rooms).
```SQL
SELECT Users.* FROM Users
INNER JOIN Rooms
    ON Users.id = Rooms.owner_id
WHERE Rooms.price = (SELECT MAX(price) FROM Rooms)
```
# Подзапросы с несколькими строками и одним столбцом

Если подзапрос возвращает более одной строки, его нельзя просто использовать с операторами сравнения, как это можно было делать со скалярными подзапросами.

Однако c подзапросами, возвращающими несколько строк и один столбец, можно использовать 3 дополнительных оператора.

**Подзапрос и оператор ALL**

С помощью оператора ALL мы можем сравнивать отдельное значение с каждым значением в наборе, полученным подзапросом. При этом данное условие вернёт TRUE, только если все сравнения отдельного значения со значениями в наборе вернут TRUE.

Например, нижеприведённый синтетический запрос проверяет для всех ли жилых помещений выполняется условие, что оно дешевле чем 200.

```sql
SELECT 200 > ALL(SELECT price FROM Rooms)
```
Или же, более практический пример: нам необходимо найти имена всех владельцев жилья, которые сами при этом никогда не снимали жилье. Чтобы получить данный список, мы можем действовать следующим образом:
- Получить список имён всех владельцев жилья
    ```sql
    SELECT DISTINCT name FROM Users INNER JOIN Rooms
    ON Users.id = Rooms.owner_id
    ```

- Получить список идентификаторов всех пользователей, снимавших жилье
    ```sql
    SELECT DISTINCT user_id FROM Reservations
    ```

- Отфильтровать первый список всех владельцев по условию, что идентификатор владельца жилья не равен ни одному из идентификаторов пользователей, когда-либо снимавших жилье
    ```sql
    SELECT DISTINCT name FROM Users INNER JOIN Rooms
        ON Users.id = Rooms.owner_id
        WHERE Users.id <> ALL (
            SELECT DISTINCT user_id FROM Reservations
        )
    ```
## Подзапрос и оператор IN

Оператор IN проверяет входит ли конкретное значение в набор значений. В качестве такого набора как раз может использоваться подзапрос, возвращающий несколько строк с одним столбцом.

Например, если нам необходимо получить всю информацию о владельцах жилья стоимостью больше 150 условных единиц, то это можно сделать следующим образом:
```sql
SELECT * FROM Users WHERE id IN (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```
## Подзапрос и оператор ANY

Условное выражение с ANY имеет схожее поведение, но оно возвращает TRUE, если хотя бы одно сравнение отдельного значения со значением в наборе вернёт TRUE.

Давайте с его помощью напишем такой же запрос, что мы делали с оператором IN: найдём пользователей, которые владеют хотя бы 1 жилым помещением стоимостью более 150.
	
```sql
SELECT * FROM Users WHERE id = ANY (
    SELECT DISTINCT owner_id FROM Rooms WHERE price >= 150
)
```

# Многостолбцовые подзапросы

До этого мы рассматривали лишь подзапросы, возвращающие один столбец. Но мы также можем работать с подзапросами, возвращающими несколько столбцов и несколько строк (производные таблицы).

## Сравнение по нескольким столбцам

SQL поддерживает сравнение не только по одной колонке, но позволяет попарно сравнивать значения в основном запросе со значениями в подзапросе.

Например, если мы хотим получить информацию о всех бронированиях, в которых цена жилья на момент брони (Reservations.price) соответствует текущей стоимостью жилья (Rooms.price). То мы это можем сделать следующим образом:

```sql
SELECT * FROM Reservations
    WHERE (room_id, price) IN (SELECT id, price FROM Rooms);
```

В данном примере, подзапрос возвращает таблицу с идентификаторами жилых помещений и их текущей ценой:

```sql
SELECT id, price FROM Rooms
```

И затем, используя эту таблицу, мы ограничиваем все бронирования только теми, в которых пара значений room_id и price найдутся в таблице подзапроса.

Это же решение можно было бы выполнить и без сравнения по нескольким колонкам, но оно было бы более объёмным:

```sql
SELECT Reservations.* FROM Reservations
INNER JOIN Rooms
ON Reservations.room_id = Rooms.id
WHERE Reservations.price = Rooms.price;
```

# Коррелированные подзапросы

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

## Пример коррелированного подзапроса

Например, следующий коррелируемый подзапрос находит кто и сколько потратил:

```sql
SELECT FamilyMembers.member_name, (
    SELECT SUM(Payments.unit_price * Payments.amount)
    FROM Payments
    WHERE Payments.family_member = FamilyMembers.member_id
) AS total_spent
FROM FamilyMembers;
```
В данном случае, коррелированный подзапрос ссылается к столбцу member_id из основного запроса.

Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой строки, которая может быть включена в окончательный результат.

Так в нашем случае основной запрос к таблице FamilyMembers возвращает 8 записей и для каждой из них выполняется коррелированный подзапрос.

	
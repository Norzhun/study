
А что если мы хотим получить информацию не о каждой записи отдельно, а о группах, которые они образуют?

Например, такими группами могут выступать записи разбитые по типу жилья:

- Shared room (аренда комнаты на несколько человек)
- Private room (аренда целой комнаты)
- Entire home/apt (аренда целой квартиры)
## Общая структура запроса с GROUP BY

```sql
SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;
```

Для того, чтобы записи у нас образовали группы по типу жилья мы должны после GROUP BY указать home_type, т.е. поле, по которому будет происходить группировка.

```sql
SELECT home_type FROM Rooms
GROUP BY home_type
```
При использовании оператора GROUP BY мы перешли от работы с отдельными записями на работу с образовавшимися группами. В связи с этим мы не можем просто вывести любое поле из записи (например, has_tv или price), как мы это могли делать раньше. Так как в каждой группе может быть несколько записей и в каждой из них в этом поле может быть разное значение.

При использовании GROUP BY мы можем выводить только:

- литералы, т.е. указанное явным образом фиксированные значения.
    
    Мы можем их выводить, так как это фиксированные значения, которые ни от чего не зависят.  
    Например,
    
    MySQL
    
    ```sql
    SELECT home_type, "literal" FROM Rooms
    GROUP BY home_type
    ```
- результаты агрегатных функций, т.е. вычисленные значения на основании набора значений. Функция AVG принимает в качестве аргумента название поля, по которому мы хотим вычислить среднее значение для каждой группы.
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
```
- поля группировки.
    
    Мы можем их выводить, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.
## Группировка по 2 и более полям

Мы уже рассмотрели как записи в таблице группируются по одному полю. Для дополнительной иллюстрации это выглядит примерно так, когда поле группировки home_type:

![Группировка по 1 полю](https://sql-academy.org/_next/image?url=%2Fstatic%2FguidePage%2Fgroupping%2Fgroupping_by_1_field.png&w=3840&q=50 "Группировка по 1 полю")

При группировке по 2 и более полям принцип остается такой же, только теперь образовавшиеся группы дополнительно разбиваются на более мелкие группы в зависимости от второго поля группировки.

Пример группировки по home_type и has_tv:

![Группировка по 2 полям](https://sql-academy.org/_next/image?url=%2Fstatic%2FguidePage%2Fgroupping%2Fgroupping_by_2_field.png&w=3840&q=50 "Группировка по 2 полям")
# Агрегатные функции

|Функция|Описание|
|:--|:--|
|SUM(поле_таблицы)|Возвращает сумму значений|
|AVG(поле_таблицы)|Возвращает среднее значение|
|COUNT(поле_таблицы)|Возвращает количество записей|
|MIN(поле_таблицы)|Возвращает минимальное значение|
|MAX(поле_таблицы)|Возвращает максимальное значение|
- Найдём количество каждого вида жилья и отсортируем полученный список по убыванию:
    ```sql
    SELECT home_type, COUNT(*) as amount FROM Rooms
    GROUP BY home_type
    ORDER BY amount DESC
    ```

- Для каждого жилого помещения найдём самую позднюю дату выезда (поле end_date)
    ```sql
	SELECT room_id, MAX(end_date) AS last_end_date 
	FROM Reservations
    GROUP BY room_id
    ```
Используйте функцию TIMESTAMPDIFF(second, time_out, time_in), чтобы получить разницу во времени в секундах между двумя датами.

# Оператор HAVING

Мы уже рассматривали запрос получения средней стоимости аренды жилых помещений в зависимости от типа жилья:
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
```
Давайте доработаем этот запрос таким образом, чтобы в итоговой выборке отображались только те группы, чья средняя стоимость больше 50.

Обладая предыдущим опытом, есть большой соблазн попытаться использовать для этих целей оператор WHERE. Но при попытке выполнить такой запрос СУБД неминуемо выдаст ошибку, указав что мы некорректно используем синтаксис WHERE avg_price > 50.
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
WHERE avg_price > 50
```
Говоря наперёд, для фильтрации групп мы должны использовать оператор HAVING:
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
HAVING avg_price > 50
```
## Порядок выполнения SQL запроса

Но почему же мы не могли использовать WHERE и зачем нужен отдельный оператор для этой цели? Все дело в порядке выполнения SQL запроса.

![Схема порядка выполнения SQL запроса](https://sql-academy.org/_next/image?url=%2Fstatic%2FguidePage%2Foperator-having%2Fsql_query_order_ru.png&w=1920&q=50 "Схема порядка выполнения SQL запроса")

Наш первый запрос был неверный, потому что мы пытались использовать поле avg_price у образовавшихся групп ещё до их образования, так как выполнение оператора WHERE предшествует группировке.

То есть оператор WHERE в момент его исполнения ничего не знает о последующей группировке, он работает только с записями из таблицы. Так мы, например, с его помощью можем отфильтровать записи таблицы Rooms по цене до применения группировки и лишь затем вычислить среднюю стоимость групп оставшегося жилья:

```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
WHERE price > 50
GROUP BY home_type
```

## Пример использования HAVING
Для примера давайте получим минимальную стоимость каждого типа жилья c телевизором. При этом нас интересуют только типы жилья, содержащие как минимум 5 жилых помещений, относящихся к ним.

Чтобы получить такой результат мы должны:

- Сначала получить все данные из таблицы

    ```sql
    SELECT ... FROM Rooms;
    ```

- Затем выбрать из всех записей таблицы Room только интересующие нас, т.е. только жильё с телевизором

    ```sql
    SELECT ... FROM Rooms
    WHERE has_tv = True
    ```

- Затем сгруппировать данные записи о жилых помещений по их типу

    ```sql
    SELECT ... FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type
    ```

- После этого отфильтровать полученные группы по условию. Нас интересуют группы, имеющие как минимум 5 представителей

    ```sql
    SELECT ... FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type
    HAVING COUNT(*) >= 5
    ```

- И под конец, посмотреть что нас просят в задании и, соответственно, добавить вывод необходимой информации. В нашем случае, нам необходимо вывести название типа жилья и его минимальную стоимость.
    ```sql
    SELECT home_type, MIN(price) as min_price FROM Rooms
    WHERE has_tv = True
    GROUP BY home_type
    HAVING COUNT(*) >= 5;
    ```
## Функции высшего порядка

Как уже сказано, функции, которые принимают или/и возвращают другие функции, называются **функциями высшего порядка**.

Давайте реализуем простейшую функцию высшего порядка:

```python
def high_order_function(func):     # функция высшего порядка, так как принимает функцию
    return func(3)


def double(x):                     # обычная функция = функция первого порядка
    return 2*x


def add_one(x):                    # обычная функция = функция первого порядка
    return x + 1
```

Здесь функция `high_order_function()` принимает другую функцию на входе и возвращает результат её вызова с аргументом, равным 3.
Приведенный ниже код:

```python
print(high_order_function(double))
print(high_order_function(add_one))
```

выводит:

```no-highlight
6
4
```
## Функции высшего порядка для обработки набора данных

Часто функции высшего порядка используются для обработки наборов данных. Рассмотрим три важные функции высшего порядка:

- `map()`;
- `filter()`;
- `reduce()`.

В языке Python эти функции уже реализованы, однако для лучшего понимания их работы мы сначала напишем свои версии этих функций, и уже после этого поговорим о встроенных реализациях.

### Функция map()

При работе со списками часто требуется применить одно и то же преобразование к каждому элементу. Можно написать цикл, содержащий нужное преобразование.

Например, для преобразования списка чисел в список их квадратов, код может выглядеть так:

```python
def f(x):
    return x**2     # тело функции, которая преобразует аргумент x


old_list = [1, 2, 4, 9, 10, 25]
new_list = []
for item in old_list:
    new_item = f(item)
    new_list.append(new_item)

print(old_list)
print(new_list)
```

Результатом работы такого кода будет:

```no-highlight
[1, 2, 4, 9, 10, 25]
[1, 4, 16, 81, 100, 625]
```

Несложно понять, что цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только преобразование, то есть применяемая функция `f()`. Так почему бы не обобщить код, чтобы функция была параметром? Так и сделаем:

```python
def map(function, items):
    result = []
    for item in items:
        new_item = function(item)
        result.append(new_item)
    return result
```

Теперь мы можем совершать преобразования, используя функцию высшего порядка `map()`.

Приведенный ниже код:

```python
def square(x):
    return x**2


def cube(x):
    return x**3


numbers = [1, 2, -3, 4, -5, 6, -9, 0]

strings = list(map(str, numbers))        # используем в качестве преобразователя - функцию str
abs_numbers = list(map(abs, numbers))    # используем в качестве преобразователя - функцию abs

squares = list(map(square, numbers))     # используем в качестве преобразователя - функцию square
cubes = list(map(cube, numbers))         # используем в качестве преобразователя - функцию cube

print(strings)
print(abs_numbers)
print(squares)
print(cubes)
```

выводит:

```no-highlight
['1', '2', '-3', '4', '-5', '6', '-9', '0']
[1, 2, 3, 4, 5, 6, 9, 0]
[1, 4, 9, 16, 25, 36, 81, 0]
[1, 8, -27, 64, -125, 216, -729, 0]
```
Реализованную нами функцию `map()` можно использовать как альтернативную возможность для преобразования типов элементов любого списка. Раньше мы решали такую задачу с помощью списочных выражений. Теперь можем использовать и функцию `map()`.

Приведенный ниже код, при условии, что функция `map()` определена как указано выше:

```python
strings = ['10', '12', '-4', '-9', '0', '1', '23', '100', '99']

numbers1 = [int(c) for c in strings]  # используем списочное выражение для преобразования
numbers2 = list(map(int, strings))    # используем функцию map() для преобразования

print(numbers1)
print(numbers2)
```

выводит:

```no-highlight
[10, 12, -4, -9, 0, 1, 23, 100, 99]
[10, 12, -4, -9, 0, 1, 23, 100, 99]
```

### Цепочки преобразований

Мы также можем строить цепочки преобразований, несколько раз вызывая функцию `map()`.

Приведенный ниже код, при условии, что функция `map()` определена как указано выше:

```python
numbers = ['-1', '20', '3', '-94', '65', '6', '-970', '8']

new_numbers = list(map(abs, map(int, numbers)))

print(new_numbers)
```

выводит:

```no-highlight
[1, 20, 3, 94, 65, 6, 970, 8]
```

То есть, сначала мы преобразуем список строк в список чисел с помощью кода `map(int, numbers)`, получая список `[-1, 20, 3, -94, 65, 6, -970, 8]`. Далее с помощью еще одного вызова функции `map()` трансформируем полученный список в список `[1, 20, 3, 94, 65, 6, 970, 8]`.

### Функция filter()

Другая популярная задача при работе со списками: отобрать часть элементов списка по определенному критерию. Функция высшего порядка для решения такой задачи называется `filter()`.

Функция-критерий, которая возвращает значение `True` или `False`, называется предикатом.

Реализация такой функции может выглядеть так:

```python
def filter(function, items):
    result = []
    for item in items:
        if function(item):        
            result.append(item)  # добавляем элемент item если функция function вернула значение True

    return result
```

Наша функция `filter()` применяет предикат `function` к каждому элементу и добавляет в итоговый список только те элементы, для которых предикат вернул `True`.

Например, чтобы из исходного списка чисел получить список с элементами, большими 1010, можно написать такой код:

```python
def is_greater10(num):   # функция возвращает значение True если число больше 10 и False в противном случае
    return num > 10


numbers = [12, 2, -30, 48, 51, -60, 19, 10, 13]

large_numbers = list(filter(is_greater10, numbers))   #  список large_numbers содержит элементы, большие 10

print(large_numbers)
```

При условии, что функция `filter()` определена, как указано выше, этот код выводит:

```no-highlight
[12, 48, 51, 19, 13]
```

Рассмотрим еще пару примеров применения реализованной функции `filter()`.

Приведенный ниже код, при условии, что функция `filter()` определена как указано выше:

```python
def is_odd(num):
    return num % 2


def is_word_long(word):
    return len(word) > 6


numbers = list(range(15))
words = ['В', 'новом', 'списке', 'останутся', 'только', 'длинные', 'слова']

odd_numbers = list(filter(is_odd, numbers))
large_words = list(filter(is_word_long, words))

print(odd_numbers)
print(large_words)
```

выводит:

```
[1, 3, 5, 7, 9, 11, 13]
['останутся', 'длинные']
```
### Функция reduce()

Реализованные нами функции `map()` и `filter()` работали с отдельными элементами списка независимо. Но встречаются циклы с агрегацией результата — формированием одного результирующего значения при комбинации элементов с использованием аргумента-аккумулятора.

Типичные примеры агрегации — сумма всех элементов списка или их произведение.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4, 5]

total = 0
product = 1

for num in numbers:
    total += num
    product *= num

print(total)
print(product)
```

вычисляет сумму и произведение элементов списка и выводит:

```no-highlight
15
120
```

С точки зрения математики сумма 1+2+3+4+5 может быть выражена как:

(((((0+1)+2)+3)+4)+5). Ноль здесь тот самый аккумулятор, точнее его начальное значение.

Несложно понять, что этот цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только начальное значение аккумулятора (0 для суммы, 1 для произведения и т.д.) и операция, которая комбинирует элемент и аккумулятор. Так почему бы не обобщить этот код? Так и сделаем:

```python
def reduce(operation, items, initial_value):
    acc = initial_value
    for item in items:
        acc = operation(acc, item)

    return acc
```

Приведенный ниже код, при условии, что функция `reduce()` определена как указано выше:

```python
def add(x, y):
    return x+y


def mult(x, y):
    return x*y


numbers = [1, 2, 3, 4, 5]

total = reduce(add, numbers, 0)
product = reduce(mult, numbers, 1)

print(total)
print(product)
```

выводит:

```no-highlight
15
120
```


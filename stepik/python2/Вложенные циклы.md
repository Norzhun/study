Оказывается, элементами списков могут быть другие списки и в реальной разработке такая конструкция оказывается очень полезной. Такие списки называются **вложенными списками**.

### Создание вложенного списка

Работа с вложенными списками принципиально ничем не отличается от работы со списками, например, чисел или строк. Чтобы создать вложенный список, мы также перечисляем элементы через запятую в квадратных скобках:

```python
my_list = [[0], [1, 2], [3, 4, 5]]
```

Переменная `my_list` ссылается на список, состоящий из других списков (с вложенными списками).
Поскольку глубина вложенности списка `my_list` равна двум, то такой список обычно называют **двумерным списком**.
Рассмотрим программный код:

```python
my_list = [[0], [1, 2], [3, 4, 5]]

print(my_list)
print(my_list[0])
print(my_list[1])
print(my_list[2])
print(len(my_list))
```

Результатом работы такого кода будет:

```no-highlight
[[0], [1, 2], [3, 4, 5]]
[0]
[1, 2]
[3, 4, 5]
3
```
### Индексация

Так как элементы списка `my_list` – строка и списки, их также можно индексировать.

Рассмотрим программный код:

```python
my_list = ['Python', [10, 20, 30], ['Beegeek', 'Stepik!']]

print(my_list[0][2])       # индексирование строки 'Python'
print(my_list[1][1])       # индексирование списка [10, 20, 30]
print(my_list[2][-1])      # индексирование списка ['Beegeek', 'Stepik!']
print(my_list[2][-1][-1])  # индексирование строки 'Stepik!'
```

Результатом работы такого кода будет:

```no-highlight
t
20
Stepik!
!
```

### Функции len(), max(), min()

####  Функция len()

Рассмотрим программный код:

```python
my_list = [[0], [1, 2], [3, 4, 5], [], [10, 20, 30]]

print(len(my_list))
```

Результатом работы такого кода будет:

```no-highlight
5
```

Если требуется посчитать общее количество элементов во вложенном списке `my_list`, мы можем использовать цикл `for` в связке с функцией `len()`:

```python
total = 0
my_list = [[0], [1, 2], [3, 4, 5], [], [10, 20, 30]]

for li in my_list:
    total += len(li)

print(total)
```

Результатом работы такого кода будет: 9

#### Функции min() и max()

Функции `min()` и `max()` могут работать и со списками. Если этим функциям передается несколько списков, то целиком возвращается один из переданных списков. При этом сравнение происходит поэлементно: сначала сравниваются первые элементы списков. Если они не равны, то функция `min()` вернет тот список, первый элемент которого меньше, `max()` – наоборот. Если первые элементы равны, то будут сравниваться вторые и т. д.

Рассмотрим программный код:

```python
list1 = [1, 7, 12, 0, 9, 100] 
list2 = [1, 7, 90] 
list3 = [1, 10]

print(min(list1, list2, list3))
print(max(list1, list2, list3))
```

Результатом работы такого кода будет:

```no-highlight
[1, 7, 12, 0, 9, 100]
[1, 10]
```

Функции `min()` и `max()` также можно использовать при работе с вложенными списками. Рассмотрим программный код:

```python
list1 = [[1, 7, 12, 0, 9, 100], [1, 7, 90], [1, 10]]
list2 = [['a', 'b'], ['a'], ['d', 'p', 'q']]

print(min(list1))
print(max(list1))
print(min(list2))
print(max(list2))
```

Результатом работы такого кода будет:

```no-highlight
[1, 7, 12, 0, 9, 100]
[1, 10]
['a']
['d', 'p', 'q']
```
## Создание вложенных списков

Иногда нужно создать вложенный список, заполненный по определенному правилу – шаблону. Например, список длиной `n`, содержащий списки длиной `m`, каждый из которых заполнен нулями.

Рассмотрим несколько способов решения задачи.

**Способ 1.** Создадим пустой список, потом `n` раз добавим в него новый элемент – список длины `m`, составленный из нулей:

```python
n, m = int(input()), int(input())    # считываем значения n и m
my_list = []

for _ in range(n):
    my_list.append([0] * m)

print(my_list)
```

Если ввести значения `n = 3`, `m = 5`, то результатом работы такого кода будет:

```no-highlight
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
```

Если передать значения `n = 5`, `m = 3`, то результатом работы такого кода будет:

```no-highlight
[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```
**Способ 2.** Сначала создадим список из `n` элементов (для начала просто из `n` нулей). Затем сделаем каждый элемент списка ссылкой на другой список из `m` элементов, заполненный нулями:

```python
n, m = int(input()), int(input())  # считываем значения n и m
my_list = [0] * n

for i in range(n):
    my_list[i] = [0] * m

print(my_list)
```

**Способ 3.** Можно использовать генератор списка: создадим список из `n` элементов, каждый из которых будет списком, состоящих из `m` нулей:

```python
n, m = int(input()), int(input())  # считываем значения n и m

my_list = [[0] * m for _ in range(n)]

print(my_list)
```

В этом случае каждый элемент создается независимо от остальных (заново конструируется вложенный список `[0] * m` для заполнения очередного элемента списка).

Обратите внимание, что очевидное решение, использующее операцию умножения списка на число (операция повторения), оказывается неверным:
```python
n, m = int(input()), int(input())  # считываем значения n и m

my_list = [[0] * m ] * n

print(my_list)
```

В этом легко убедиться, если присвоить элементу `my_list[0][0]` любое значение, например, `17`, а затем вывести список на печать:

```python
n, m = int(input()), int(input())

my_list = [[0] * m ] * n
my_list[0][0] = 17

print(my_list)
```

Если ввести значения `n = 5`, `m = 3`, то результатом работы такого кода будет:

```no-highlight
[[17, 0, 0], [17, 0, 0], [17, 0, 0], [17, 0, 0], [17, 0, 0]]
```

То есть, изменив значение элемента списка `my_list[0][0]`, мы также изменили значения элементов `my_list[1][0]`, `my_list[2][0]`, `my_list[3][0]`, `my_list[4][0]`.

Причина такого поведения кроется в самой природе списков (тип  `list`). В Python списки – ссылочный тип данных. Конструкция `[0] * m` возвращает **ccылку** на список из `m` нулей. Повторение этого элемента создает список из `n` ссылок на один и тот же список.

## Считывание вложенных списков

Если элементы списка вводятся через клавиатуру (каждая строка на отдельной строке, всего `n` строк, числа в строке разделяются пробелами), для ввода списка можно использовать следующий код:

```python
n = 4                                         # количество строк (элементов)
my_list = []

for _ in range(n):
    elem = [int(i) for i in input().split()]  # создаем список из элементов строки
    my_list.append(elem)
```

В этом примере мы используем списочный метод `append()`, передавая ему в качестве аргумента другой список. Так у нас получается список списков.

В результате, если на вход программе подаются строки:

```no-highlight
2 4
6 7 8 9
1 3
5 6 5 4 3 1
```
то в переменной `my_list` будет храниться список:

```no-highlight
[[2, 4], [6, 7, 8, 9], [1, 3], [5, 6, 5, 4, 3, 1]]
```

Также следует помнить отличие работы списочных методов `append()` и `extend()`.

Следующий код:

```python
n = 4
my_list = []

for _ in range(n):
    elem = [int(i) for i in input().split()]
    my_list.extend(elem)
```

создает одномерный **(!)** список, а не вложенный. В переменной `my_list` будет храниться список:

```no-highlight
[2, 4, 6, 7, 8, 9, 1, 3, 5, 6, 5, 4, 3, 1]
```
## Перебор и вывод элементов вложенного списка

Когда нужно перебрать все элементы вложенного списка (например, чтобы вывести их на экран), обычно используются **вложенные циклы**.

Рассмотрим программный код:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for i in range(len(my_list)):
    for j in range(len(my_list[i])):
        print(my_list[i][j], end=' ')  # используем необязательный параметр end
    print()                            # перенос на новую строку
```

 Результатом работы такого кода будет:

```no-highlight
1 2 3 
4 5 6 
7 8 9 
```
В предыдущем примере мы перебирали **индексы элементов**, а можно сразу перебирать сами элементы вложенного списка:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in my_list:
    for elem in row:
        print(elem, end=' ')
    print()
```

 Результатом работы такого кода будет:

```no-highlight
1 2 3 
4 5 6 
7 8 9 
```
Перебор элементов вложенного списка по индексам дает нам больше гибкости для вывода данных. Например, поменяв порядок переменных `i` и `j`, мы получаем иной тип вывода:

```python
my_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for i in range(len(my_list)):
    for j in range(len(my_list[i])):
        print(my_list[j][i], end=' ')  # выводим my_list[j][i] вместо my_list[i][j]
    print()
```

 Результатом работы такого кода будет:

```no-highlight
1 4 7 
2 5 8 
3 6 9 
```

Названия переменных `row` (строка) и `elem` (элемент) удобно использовать при переборе вложенного списка по значениям. Названия переменных `i` и `j` используются при переборе вложенного списка по индексам.
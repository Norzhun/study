## Позиционные аргументы

Все ранее написанные нами функции имели **позиционные аргументы**. Такие аргументы передаются без указания имен. Они называются **позиционными**, потому что именно по позиции, расположению аргумента, функция понимает, какому параметру он соответствует.

Рассмотрим следующий код: 

```python
def diff(x, y):
    return x - y


res = diff(10, 3)    # используем позиционные аргументы
print(res)
```

Такой код выведет число 7. При вызове функции `diff()` **первому** параметру `x` будет соответствовать **первый** переданный аргумент, 10, а **второму** параметру `y`  — **второй** аргумент, 3.

В Python можно использовать не только позиционные, но и именованные аргументы.
## Именованные аргументы

Аргументы, передаваемые с именами, называются **именованными**. При вызове функции можно использовать имена параметров из ее определения. Исключение составляют списки аргументов неопределенной длины, где используются аргументы со звездочкой, но об этом в следующем уроке. Все функции из предыдущих уроков можно вызывать, передавая им именованные аргументы.

Рассмотрим следующий код: 

```python
def diff(x, y):
    return x - y


res = diff(x=10, y=3)   # используем именованные аргументы
print(res)
```

Такой код по-прежнему выведет число 7. При вызове функции `diff()` мы явно указываем, что параметру `x` соответствует аргумент 10 а параметру `y`— аргумент 3.

Использование именованных аргументов позволяет нарушать их позиционный порядок при вызове функции. Порядок упоминания именованных аргументов не имеет значения!

Мы можем вызвать функцию `diff()` так:

```python
res = diff(y=3, x=10)
```

и получить тот же результат 7.
### Когда стоит применять именованные аргументы

Каких-то строгих правил на этот счёт не существует. Однако широко практикуется такой подход: если функция принимает больше трёх аргументов, нужно хотя бы часть из них указать по имени. 

Рассмотрим определение функции `make_circle()` для рисования круга:

```python
def make_circle(x, y, radius, line_width, fill):
    # тело функции
```

Вызвать такую функцию можно так:

```python
make_circle(200, 300, 17, 2.5, True)
```
Сравните:

```python
make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True)
```

Такой код читать значительно проще!
### Комбинирование позиционных и именованных аргументов

Мы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны **до** любых именованных!

Для функции `diff()` код:

```python
res = diff(10, y=3)   # используем позиционный и именованный аргумент
```

работает как полагается, при этом параметру `x` соответствует значение 10.

Приведенный ниже код:

```python
res = diff(x=10, 3)   # используем позиционный и именованный аргумент
```

приводит к возникновению ошибки `SyntaxError: positional argument follows keyword argument`.
## Необязательные аргументы

Бывает, что какой-то параметр функции часто принимает одно и то же значение. Например, для функции `print()` создатели языка Python установили значения параметров `sep` и `end` равными символу пробела и символу перевода строки, поскольку эти значения используют наиболее часто.

Другим примером служит функция `int()` , преобразующая строку в число. Она принимает два аргумента:

- первый аргумент: строка, которую нужно преобразовать в число;
- второй аргумент: основание [системы счисления](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F).

Это позволяет ей считывать числа в различных системах счисления.

Приведенный ниже код, преобразует двоичное число 101101:

```python
num = int('101', 2)     # аргумент 2 указывает на то, что число 101 записано в двоичной системе
```

В переменной `num` будет храниться число 5, так как 101(2)=510(10)​.

Но чаще всего эта функция используется для считывания из строки чисел, записанных в десятичной системе счисления. Утомительно каждый раз писать 10 вторым аргументом. У функции `int()` второй параметр по умолчанию равен 10, и потому можно вызывать эту функцию с одним аргументом. 

Чтобы задать **значение параметра по умолчанию**, в списке параметров функции достаточно после имени переменной написать знак равенства и нужное значение.

Параметры со значением по умолчанию идут последними.

Рассмотрим все то же определение функции `make_circle()`, которая рисует круг:

```python
def make_circle(x, y, radius, line_width, fill):
    # тело функции
```

Поскольку обычно нам нужно рисовать круг с шириной линии, равной 1 с заливкой, то логично установить данные значения в качестве значений по умолчанию:

```python
def make_circle(x, y, radius, line_width=1, fill=True):
    # тело функции
```

Теперь для того, чтобы нарисовать стандартный круг мы вызываем функцию так:

```python
make_circle(100, 50, 20)
```

или так:

```python
make_circle(x=100, y=50, radius=20)
```

Если вам хочется поменять ширину линии и заливку, то вы легко можете это сделать:

```python
make_circle(x=100, y=50, radius=20, fill=False)                   # line_width=1, fill=False
make_circle(x=100, y=50, radius=20, line_width=3)                 # fill=True, line_width=3
make_circle(x=100, y=50, radius=20, line_width=5, fill=False)     # line_width=5, fill=False
```

	### Изменяемые типы в качестве значений по умолчанию

При использовании **изменяемых типов данных** в качестве значения параметра по умолчанию можно столкнуться с неожиданными результатами работы функции.

Рассмотрим определение функции `append()`, где в качестве значения по умолчанию используется изменяемый тип данных (список, тип `list`):

```python
def append(element, seq=[]):
    seq.append(element)
    return seq
```

Вызывая функцию `append()` следующим образом:

```python
print(append(10, [1, 2, 3]))
print(append(5, [1]))
print(append(1, []))
print(append(3, [4, 5]))
```

получим ожидаемый вывод:

```no-highlight
[1, 2, 3, 10]
[1, 5]
[1]
[4, 5, 3]
```

А если вызовем функцию `append()` так:

```python
print(append(10))
print(append(5))
print(append(1))
```

 получим **не совсем** ожидаемый вывод:

```no-highlight
[10]
[10, 5]
[10, 5, 1]
```

Что происходит? Значение по умолчанию для параметра создается единожды при определении функции и становится атрибутом функции. 

Чтобы посмотреть значения по умолчанию, можно использовать атрибут `__defaults__`.

Приведенный ниже код:

```python
def append(element, seq=[]):
    seq.append(element)
    return seq

print('Значение по умолчанию', append.__defaults__)
print(append(10))
print('Значение по умолчанию', append.__defaults__)
print(append(5))
print('Значение по умолчанию', append.__defaults__)
print(append(1))
print('Значение по умолчанию', append.__defaults__)
```

выводит:

```no-highlight
Значение по умолчанию ([],)
[10]
Значение по умолчанию ([10],)
[10, 5]
Значение по умолчанию ([10, 5],)
[10, 5, 1]
Значение по умолчанию ([10, 5, 1],)
```

Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:

```python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq
```

Вызывая функцию `append()` следующим образом:

```python
print(append(10))
print(append(5))
print(append(1))
```

 получим **ожидаемый вывод**:

```no-highlight
[10]
[5]
[1]
```
## Организация обработки наборов аргументов переменной длины

  
Здесь речь пойдёт о конструкциях `*args` и `**kwargs`. Когда эти конструкции используются при объявлении функции, мы ожидаем, что при вызове функции наборы аргументов произвольной длины будут представлены в виде параметров `args` и `kwargs`. При применении конструкции `*args` в параметр `args` попадают позиционные аргументы, представляемые в виде кортежа. При применении `**kwargs` в `kwargs` попадают именованные аргументы, представленные в виде словаря.  

В заголовке функции  указан всего один параметр `args`, но со звездочкой перед ним. Звездочка в определении функции означает, что переменная (параметр) `args` получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца.

При описании функции можно использовать **только один** параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений.

```
def foo(*args):
    print(args)

a, b, c = 1, 2, 3

foo(a, b, c)                # Выводит (1, 2, 3)
foo(a, b)                   # Выводит (1, 2)
foo(a)                      # Выводит (1)
foo(b, c)                   # Выводит (2, 3)
```

  
Этот код доказывает то, что в параметре `args` хранится кортеж, содержащий то, что передано функции при её вызове.
```
def foo(**kwargs):
    print(kwargs)

foo(a=1, b=2, c=3)        # Выводит {'a': 1, 'b': 2, 'c': 3}
foo(a=1, b=2)             # Выводит {'a': 1, 'b': 2}
foo(a=1)                  # Выводит {'a': 1}
foo(b=2, c=3)             # Выводит {'b': 2, 'c': 3}
```

  
В вышеприведённом коде показано то, что в параметре `kwargs` хранится словарь, состоящий из пар ключ-значение и представляющий именованные аргументы, переданные функции при вызове.

А теперь давайте соберём вместе всё то, что мы разобрали в пунктах №1, №2, №3 и №4, и со всем этим поэкспериментируем, исследовав разные комбинации аргументов, которые можно передавать функциям при их вызове.  
  

```
def foo(*args,**kwargs):
    print(args, kwargs)

foo(a=1,)
# () {'a': 1}

foo(a=1, b=2, c=3)
# () {'a': 1, 'b': 2, 'c': 3}

foo(1, 2, a=1, b=2)
# (1, 2) {'a': 1, 'b': 2}

foo(1, 2)
# (1, 2) {}
```
А вот — ещё одно правило. Оно заключается в том, что конструкцию `*args` нельзя использовать после конструкции `**kwargs`.  
  

```
def foo(**kwargs, *args):
    print(kwargs, args)
>>>
    def foo(**kwargs, *args):
                      ^
SyntaxError: invalid syntax
```
## Распаковка аргументов

  
В предыдущих разделах мы говорили о том, как собирать в кортежи и словари наборы аргументов, передаваемых функциям. А здесь мы обсудим обратную операцию. А именно, разберём механизм, позволяющий распаковывать аргументы, подаваемые на вход функции.  
  

```
args = (1, 2, 3, 4)
print(*args)                  # Выводит 1 2 3 4
print(args)                   # Выводит (1, 2, 3, 4)

kwargs = { 'a':1, 'b':2}
print(kwargs)                 # Выводит {'a': 1, 'b': 2}
print(*kwargs)                # Выводит a b
```
Распаковывать переменные можно с помощью синтаксических конструкций `*` и `**`. Вот как выглядит их использование при передаче в функции кортежей, списков и словарей.  
  

```
def foo(a, b=0, *args, **kwargs):
    print(a, b, args, kwargs)

tup = (1, 2, 3, 4)
lst = [1, 2, 3, 4]
d = {'e':1, 'f':2, 'g':'3'}

foo(*tup)             # foo(1, 2, 3, 4)
# 1 2 (3, 4) {}

foo(*lst)             # foo(1, 2, 3, 4)
# 1 2 (3, 4) {}

foo(1, *tup)          # foo(1, 1, 2, 3, 4)
# 1 1 (2, 3, 4) {}

foo(1, 5, *tup)       # foo(1, 5, 1, 2, 3, 4)
# 1 5 (1, 2, 3, 4) {}

foo(1, *tup, **d)     # foo(1, 1, 2, 3, 4 ,e=1 ,f=2, g=3)
# 1 1 (2, 3, 4) {'e': 1, 'f': 2, 'g': '3'}

foo(*tup, **d)         # foo(1, 1, 2, 3, 4 ,e=1 ,f=2, g=3)
# 1 2 (3, 4) {'e': 1, 'f': 2, 'g': '3'}
d['b'] = 45
foo(2, **d)             # foo(1, e=1 ,f=2, g=3, b=45)
# 2 45 () {'e': 1, 'f': 2, 'g': '3'}
```

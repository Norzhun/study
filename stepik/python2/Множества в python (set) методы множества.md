Важно знать:

- все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
- множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
- элементы множества должны относиться к неизменяемым типам данных;
- хранящиеся в множестве элементы могут иметь разные типы данных.
### Создание множества

Чтобы создать множество, нужно перечислить его элементы через запятую в фигурных скобках:

```python
numbers = {2, 4, 6, 8, 10}
languages = {'Python', 'C#', 'C++', 'Java'}
```
Множества могут содержать значения **разных типов данных**:

```python
info = {'Timur', 1992, 61.5}
```
Функция `print()` выводит на экран элементы множества, в фигурных скобках, разделенные запятыми:

```no-highlight
{2, 4, 6, 8, 10}
{'C#', 'Python', 'Java', 'C++'}
```
Обратите внимание: при выводе множества порядок элементов может отличаться от существовавшего при его создании, поскольку множества — неупорядоченные коллекции данных.
### Пустое множество

Создать пустое множество можно с помощью встроенной функции, которая называется `set()`:

```python
myset = set()   # пустое множество
```
### Встроенная функция set()

Встроенная функция `set()` помимо создания пустого множества может преобразовывать некоторые типы объектов в множества.

В функцию `set()` можно передать один аргумент. Передаваемый аргумент должен быть итерируемым объектом, таким как список, кортеж или строковое значение. Отдельные элементы объекта, передаваемого в качестве аргумента, становятся элементами множества:

```python
myset1 = set(range(10))          # множество из элементов последовательности
myset2 = set([1, 2, 3, 4, 5])    # множество из элементов списка
myset3 = set('abcd')             # множество из элементов строки
myset4 = set((10, 20, 30, 40))   # множество из элементов кортежа
```

Пустое множество также можно создать передав функции `set()` в качестве аргумента пустой список, строку или кортеж:

```python
emptyset1 = set([])         # пустое множество из пустого списка
emptyset2 = set('')         # пустое множество из пустой строки
emptyset3 = set(())         # пустое множество из пустого кортежа
```
## Дубликаты при создании множеств

Множества не могут содержать повторяющиеся элементы. Если в функцию `set()` передать аргумент, содержащий повторяющиеся элементы, то в множестве появится только один из этих повторяющихся элементов.

Приведенный ниже код:

```python
myset1 = {2, 2, 4, 6, 6}
​myset2 = set([1, 2, 2, 3, 3])
myset3 = set('aaaaabbbbccccddd')

print(myset1)
print(myset2)
print(myset3)
```

выводит (порядок элементов может отличаться):

```no-highlight
{2, 4, 6}
{1, 2, 3}
{'b', 'c', 'd', 'a'}
```

Если требуется создать множество, в котором каждый элемент — строковое значение, содержащее более одного символа, то используем код:

```python
myset = set(['aaa', 'bbbb', 'cc'])

print(myset)
```

Приведенный выше код выводит (порядок элементов может отличаться):

```python
{'bbbb', 'aaa', 'cc'}
```

Если же создать множество следующим образом:

```python
myset = set('aaa bbbb cc')

print(myset)
```

то мы получим (порядок элементов может отличаться):

```no-highlight
{' ', 'c', 'a', 'b'}
```
**Примечание 1.** Элементы множества могут принадлежать любому **неизменяемому типу данных*, быть числами, строками, кортежами. Элементы изменяемых типов данных не могут входить в множества, в частности, нельзя сделать элементом множества список или другое множество. Требование неизменяемости элементов множества накладывается особенностями представления множеств в Python.

Приведенный ниже код:

```python
myset1 = {1, 2, [5, 6], 7}    # множество не может содержать список
myset2 = {1, 2, {5, 6}, 7}    # множество не может содержать множество
```

приводит к ошибке:

```no-highlight
TypeError: unhashable type: 'list'
TypeError: unhashable type: 'set'
```

Однако приведенный ниже код:

```python
myset = {1, 2, (5, 6), 7}    # множество может содержать кортеж
```

работает как полагается.

Работа с множествами очень сильно напоминает работу со списками, поскольку и множества, и списки содержат отдельные элементы, хотя элементы множества уникальны, а списки могут содержать повторяющиеся элементы. Многое из того, что мы делали со списками, доступно и при работе с множествами.

**Примечание 2.** Операция конкатенации `+` и умножения на число `*` **недоступны** для множеств.

Мы также можем использовать операцию **распаковки множества**.

Приведенный ниже код:

```python
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}

print(*numbers, sep='\n')
```

Не стоит забывать, что множества – неупорядоченные коллекции, поэтому полагаться на порядок вывода элементов не стоит. Если нужно гарантировать порядок вывода элементов (по возрастанию / убыванию), то необходимо воспользоваться встроенной функцией `sorted()`.

Приведенный ниже код:

```python
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}

sorted_numbers = sorted(numbers)
print(*sorted_numbers, sep='\n')
```

будет **гарантированно** выводить элементы множества в порядке возрастания.

**Примечание 1.** Встроенная функция `sorted()` имеет опциональный параметр `reverse`. Если установить этот параметр в значение `True`, произойдет сортировка по убыванию.
Приведенный ниже код:

```python
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}

sortnumbers = sorted(numbers, reverse=True)
print(*sortnumbers, sep='\n')
```

гарантированно выводит:

```no-highlight
7
6
5
3
2
1
0
```

Обратите внимание на то, что функция `sorted()` возвращает отсортированный список, а не множество. Не путайте встроенную функцию `sorted()` и списочный метод `sort()`. Множества **не содержат** метода `sort()`.
## Сравнение множеств

Множества можно сравнивать между собой. Равные множества имеют одинаковую длину и содержат равные элементы. Для сравнения множеств используются операторы `==` и `!=`.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 3, 3, 3}
myset2 = {2, 1, 3}
myset3 = {1, 2, 3, 4}

print(myset1 == myset2)
print(myset1 == myset3)
print(myset1 != myset3)
```

выводит:

```no-highlight
True
False
True
```
### Метод add()

Для добавления нового элемента в множество используется метод `add()`.

Следующий программный код:

```python
numbers = {1, 1, 2, 3, 5, 8, 3}  # создаем множество

numbers.add(21)  # добавляем число 21 в множество
numbers.add(34)  # добавляем число 34 в множество

print(numbers)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 3, 34, 5, 8, 21}
```
Если требуется внести несколько значений в множество, то можно воспользоваться циклом `for`.

Следующий программный код:

```python
numbers = set()  # создаем пустое множество

for i in range(10):
    numbers.add(i*i + 1)

print(numbers)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 65, 5, 37, 10, 17, 50, 82, 26}
```
## Удаление элемента

Для удаления элементов из множества используются методы:

-     `remove()`;
-     `discard()`;
-     `pop()`.

### Метод remove()

Метод `remove()` — удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.

Следующий программный код:

```python
numbers = {1, 2, 3, 4, 5}

numbers.remove(3)
print(numbers)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 4, 5}
```

Следующий программный код:

```python
numbers = {1, 2, 3, 4, 5}

numbers.remove(10)
print(numbers)
```

приводит к возникновению ошибки `KeyError`, так как элемент 10 отсутствует в множестве.

### Метод discard()

Метод `discard()` — удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.

Следующий программный код:

```python
numbers = {1, 2, 3, 4, 5}

numbers.discard(10)
print(numbers)
```

не приводит к возникновению ошибки и выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 3, 4, 5}
```
### Метод pop()

Метод `pop()` — удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества.

Рассмотрим программный код:

```python
numbers = {1, 2, 3, 4, 5}

print('до удаления:', numbers)
num = numbers.pop()                 # удаляет случайный элемент множества, возвращая его
print('удалённый элемент:', num)
print('после удаления:', numbers)
```

Результат работы такого кода случаен, например, такой код может вывести:

```no-highlight
до удаления: {1, 2, 3, 4, 5}
удалённый элемент: 1
после удаления: {2, 3, 4, 5}
```
### Метод clear()

Метод `clear()` удаляет все элементы из множества.

Следующий программный код:

```python
numbers = {1, 2, 3, 4, 5}
numbers.clear()

print(numbers)
```

выведет:

```no-highlight
set()
```

В результате получили пустое множество.
### Объединение множеств: метод union()

**Объединение** множеств – это множество, состоящее из элементов, принадлежащих хотя бы одному из объединяемых множеств. Для этой операции существует метод `union()`.
Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1.union(myset2)
print(myset3)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 3, 4, 5, 6, 7, 8}
```
### Пересечение множеств: метод intersection()

**Пересечение** множеств – это множество, состоящее из элементов, принадлежащих одновременно каждому из пересекающихся множеств. Для этой операции существует метод `intersection()`.
Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1.intersection(myset2)
print(myset3)
```

выводит (порядок элементов может отличаться):

```no-highlight
{3, 4}
```
Для пересечения двух множеств можно также использовать оператор `&`.

Результат выполнения приведенного ниже кода:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1 & myset2
print(myset3)
```

аналогичен предыдущему.
### Разность множеств: метод difference()

**Разность** множеств – это множество, в которое входят все элементы первого множества, не входящие во второе множество. Для этой операции существует метод `difference()`.
Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1.difference(myset2)
print(myset3)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 5}
```

Для разности двух множеств можно также использовать оператор `-`.

Результат выполнения приведенного ниже кода:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1 - myset2
print(myset3)
```
### Симметрическая разность: метод symmetric_difference()

**Симметрическая разность** множеств – это множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам. Для этой операции существует метод `symmetric_difference()`.
Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1.symmetric_difference(myset2)
print(myset3)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 5, 6, 7, 8}
```

Для симметрической разности двух множеств можно также использовать оператор `^`.

Результат выполнения приведенного ниже кода:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset3 = myset1 ^ myset2
print(myset3)
```

аналогичен предыдущему.
​Обратите внимание: для операции симметрической разности порядок множеств не важен, на то она и симметрическая: `myset1 ^ myset2 == myset2 ^ myset1`.
## Методы множеств, изменяющие текущие множества

Методы `union()`, `intersection()`, `difference()`, `symmetric_difference()` не изменяют исходные множества, а возвращают новые. Часто на практике нужно изменять исходные множества. Для таких целей используются парные методы `update()`, `intersection_update()`, `difference_update()`, `symmetric_difference_update()`.

### Метод update()

Метод `update()` изменяет исходное множество **по объединению**.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1.update(myset2)  # изменяем множество myset1
print(myset1)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 3, 4, 5, 6, 7, 8}
```

Аналогичный результат получается, если использовать оператор `|=`:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1 |= myset2
print(myset1)
```
### Метод intersection_update()

Метод `intersection_update()` изменяет исходное множество **по пересечению**.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1.intersection_update(myset2)  # изменяем множество myset1
print(myset1)
```

выводит (порядок элементов может отличаться):

```no-highlight
{3, 4}
```

Аналогичный результат получается, если использовать оператор `&=`:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1 &= myset2
print(myset1)
```
### Метод difference_update()

Метод `difference_update()` изменяет исходное множество **по разности**.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1.difference_update(myset2)  # изменяем множество myset1
print(myset1)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 5}
```

Аналогичный результат получается, если использовать оператор `-=`:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1 -= myset2
print(myset1)
```
### Метод symmetric_difference_update()

Метод `symmetric_difference_update()` изменяет исходное множество **по симметрической разности**.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1.symmetric_difference_update(myset2)  # изменяем множество myset1
print(myset1)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 2, 5, 6, 7, 8}
```

Аналогичный результат получается, если использовать оператор `^=`:

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}

myset1 ^= myset2
print(myset1)
```
**Примечание 1.** Все основные операции над множествами выполняются двумя способами: при помощи метода или соответствующего ему оператора. Различие заключается в том, что метод может принимать в качестве аргумента не только множество (тип данных `set`), но и любой итерируемый объект (список, строку, кортеж..).

Приведенный ниже код:

```python
mylist = [2021, 2020, 2019, 2018, 2017, 2016]
mytuple = (2021, 2020, 2016)
mystr = 'abcd'

myset = {2009, 2010, 2016}

print(myset.union(mystr))                      # объединяем со строкой
print(myset.intersection(mylist))              # пересекаем со списком
print(myset.difference(mytuple))               # находим разность с кортежем
```

выводит (порядок элементов может отличаться):

```no-highlight
{2016, 'c', 'b', 'a', 'd', 2009, 2010}
{2016}
{2009, 2010}
```

Приведенный ниже код:

```python
mylist = [2021, 2020, 2019, 2018, 2017, 2016]
mytuple = (2021, 2020, 2016)
mystr = 'abcd'

myset = {2009, 2010, 2016}

print(myset | mystr)
print(myset & mylist)
print(myset - mytuple)
```

приводит к возникновению ошибок:

```no-highlight
TypeError: unsupported operand type(s) for |: 'set' and 'str'
TypeError: unsupported operand type(s) for &: 'set' and 'list'
TypeError: unsupported operand type(s) for -: 'set' and 'tuple'
```
**Примечание 2.** Некоторые методы (`union()`, `intersection()`, `difference()`) и операторы (`|`, `&`, `-`, `^`) позволяют совершать операции над несколькими множествами сразу.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5, 6}
myset2 = {2, 3, 4, 5}
myset3 = {5, 6, 7, 8}

union1 = myset1.union(myset2, myset3)
union2 = myset1 | myset2 | myset3

difference1 = myset1.difference(myset2, myset3)
difference2 = myset1 - myset2 - myset3           # порядок выполнения слева-направо

print(union1 == union2)
print(difference1 == difference2)
```

выводит:

```no-highlight
True
True
```
**Примечание 3.** Оператор `^` симметрической разности позволяет использовать несколько множеств, а метод `symmetric_difference()` – нет.

Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5, 6}
myset2 = {2, 3, 4, 7}
myset3 = {6, 20, 30}

symdifference = myset1 ^ myset2 ^ myset3  # порядок выполнения слева-направо

print(symdifference)
```

выводит (порядок элементов может отличаться):

```no-highlight
{1, 5, 7, 20, 30}
```

 Приведенный ниже код:

```python
myset1 = {1, 2, 3, 4, 5, 6}
myset2 = {2, 3, 4, 7}
myset3 = {6, 20, 30}

symdifference = myset1.symmetric_difference(myset2, myset3)

print(symdifference)
```

приводит к ошибке:

```no-highlight
TypeError: symmetric_difference() takes exactly one argument (2 given)
```
![[Pasted image 20231103145437.png]]
![[Pasted image 20231103145456.png]]
### Метод issubset()

Для определения, является ли одно из множеств подмножеством другого, используется метод `issubset()`. Данный метод возвращает значение `True`, если одно множество является подмножеством другого, и `False`, если не является.

Приведенный ниже код:

```python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}

print(set1.issubset(set2))
```

выводит:

```no-highlight
True
```
Для определения, является ли одно из множеств подмножеством другого, также применяются операторы `<=` (нестрогое подмножество) и `<` (строгое подмножество).

Приведенный ниже код:

```python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}

print(set1 <= set2)
```

аналогичен предыдущему.
### Метод issuperset()
Для определения, является ли одно из множеств надмножеством другого, используется метод `issuperset()`. Данный метод возвращает значение `True`, если одно множество является надмножеством другого, в противном случае он возвращает `False`.

Приведенный ниже код:

```python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}

print(set1.issuperset(set2))
```

выводит:

```no-highlight
True
```
Для определения, является ли одно из множеств надмножеством другого, также применяются операторы `>=` (нестрогое надмножество) и `>` (строгое надмножество).

Приведенный ниже код:

```python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}

print(set1 >= set2)
```

аналогичен предыдущему.
### Метод isdisjoint()

Для определения отсутствия общих элементов в множествах используется метод `isdisjoint()`. Данный метод возвращает значение `True`, если множества не имеют общих элементов, и  `False`, когда множества имеют общие элементы.

Приведенный ниже код:

```python
set1 = {1, 2, 3, 4, 5}
set2 = {5, 6, 7}
set3 = {7, 8, 9}

print(set1.isdisjoint(set2))
print(set1.isdisjoint(set3))
print(set2.isdisjoint(set3))
```

выводит:

```no-highlight
False
True
False
```
![[Pasted image 20231103155704.png]]
Мы изучили списки и строки. Списки – изменяемые коллекции, строки – неизменяемые последовательности Unicode символов. В Python имеются и неизменяемые последовательности содержащие, в отличие от строк, абсолютно произвольные данные. Такие коллекции называются **кортежами** (`tuple`, читается "тюпл").
Рассмотрим следующий программный код:

```python
my_list = [1, 2, 3, 4, 5]
```

Мы объявили список чисел и присвоили его переменной `my_list`. Содержимое списка можно изменять.

Заменив квадратные скобки при объявлении списка на круглые, мы объявляем кортеж:

```python
my_tuple = (1, 2, 3, 4, 5)
```

Кортежи по своей природе (задумке) – **неизменяемые аналоги списков**. Поэтому программный код:

```python
my_tuple = (1, 2, 3, 4, 5)
my_tuple[0] = 9
my_tuple[4] = 7
print(my_tuple)
```

приводит к ошибке

```no-highlight
TypeError: 'tuple' object does not support item assignment
```
В литеральной форме кортеж записывается в виде последовательности элементов в круглых скобках, а список – в квадратных.

## Примеры кортежей

```python
empty_tuple = ()                                      # пустой кортеж
point = (1.5, 6.0)                                    # кортеж из двух чисел
names = ('Timur', 'Ruslan', 'Roman')                  # кортеж из трех строк
info = ('Timur', 'Guev', 28, 170, 60, False)          # кортеж из 6 элементов разных типов
nested_tuple = (('one', 'two'), ['three', 'four'])    # кортеж из кортежа и списка
```
## Кортеж с одним элементом

Для создания кортежа с единственным элементом после значения элемента ставят замыкающую запятую:

```python
my_tuple = (1,)
print(type(my_tuple))     # <class 'tuple'>
```

Если запятую пропустить, то кортеж создан не будет. Например, приведенный ниже код просто присваивает переменной `my_tuple` целочисленное значение `1`:

```python
my_tuple = (1)
print(type(my_tuple))     # <class 'int'>
```
## Зачем использовать кортеж вместо списка?

Списки могут делать то же, что кортежи, и даже больше. Но **неизменяемость** **кортежей** обеспечивает им особые свойства:

- **скорость** – кортежи быстрее работают, так как из-за неизменяемости хранятся в памяти иначе, и операции с их элементами выполняются заведомо быстрее, чем с компонентами списка. Одна из причин существования кортежей  – производительность. Обработка кортежа выполняется быстрее, чем обработка списка, поэтому кортежи удобны для обработки большого объема неизменных данных.
- **безопасность** – неизменяемость превращает их в идеальные константы. Заданные кортежами константы делают код более читаемым и безопасным. Кроме того, в кортеже можно безопасно хранить данные, не опасаясь, что они будут случайно или преднамеренно изменены в программе.
## Примечания

**Примечание 1.** Мы уже  сталкивались с кортежами, когда изучали функции, возвращающие несколько значений. Такие функции возвращают именно кортежи.

Рассмотрим функцию `get_powers()`, которая принимает в качестве аргумента число и возвращает его 22, 33 и 44 степень.

```python
def get_powers(num):
    return num**2, num**3, num**4
```

Результатом выполнения следующего кода:

```python
result = get_powers(5)
print(type(result))
print(result)
```

будет:

```
<class 'tuple'>
(25, 125, 625)
```

**Примечание 2.** Списки предназначены для объединения неопределенного количества однородных сущностей. Кортежи, как правило, объединяют под одним именем несколько разнородных объектов, имеющих различный смысл.

**Примечание 3.** Тот факт, что кортеж является неизменяемым вовсе не означает, что мы не можем поменять содержимое списка в кортеже.

Приведенный ниже код:

```python
my_tuple = (1, 'python', [1, 2, 3])
print(my_tuple)
my_tuple[2][0] = 100
my_tuple[2].append(17)
print(my_tuple)
```

выводит:

```no-highlight
(1, 'python', [1, 2, 3])
(1, 'python', [100, 2, 3, 17])
```

При этом важно понимать: меняется список, а не кортеж. Списки являются ссылочными типами данных, поэтому в кортеже хранится ссылка на список, которая не меняется при изменении самого списка.
## Функция tuple()

Встроенная функция `list()` может применяться для преобразования **кортежа в список**.

Приведенный ниже код:

```python
number_tuple = (1, 2, 3, 4, 5)
number_list = list(number_tuple)
print(number_list)
```

выводит:

```python
[1, 2, 3, 4, 5]
```

Встроенная функция `tuple()`  может применяться для преобразования **списка в кортеж**.

Приведенный ниже код:

```python
str_list = ['один', 'два', 'три']
str_tuple = tuple(str_list)
print(str_tuple)
```

выводит:

```python
('один', 'два', 'три')
```
Аналогичным образом мы можем создать кортеж на основании строки.

Приведенный ниже код:

```python
text = 'hello python'
str_tuple = tuple(text)
print(str_tuple)
```

выводит:

```no-highlight
('h', 'e', 'l', 'l', 'o', ' ', 'p', 'y', 't', 'h', 'o', 'n')
```
Преобразование строки в список позволяет получить список символов строки. Это может быть полезно, например, когда надо изменить один символ строки:

```python
s = 'симпотичный'
print(s)
a = list(s)
a[4] = 'а'
s = ''.join(a)
print(s)
```

Приведенный выше код выводит:

```no-highlight
симпотичный
симпатичный
```
С этой же целью может потребоваться преобразование кортежа в список:

```python
writer = ('Лев Толстой', 1827)
print(writer)
a = list(writer)
a[1] = 1828
writer = tuple(a)
print(writer)
```

Приведенный выше код выводит:

```no-highlight
('Лев Толстой', 1827)
('Лев Толстой', 1828)
```
## Особенности кортежей

Кортежи поддерживают те же операции, что и списки, за исключением изменяющих содержимое.

Кортежи поддерживают:

- доступ к элементу по индексу (только для получения значений элементов);
- методы, в частности `index()`, `count()`;
- встроенные функции, в частности `len()`, `sum()`, `min()` и `max()`;
- срезы;
- оператор принадлежности `in`;
- операторы конкатенации `(+)` и повторения `(*)`.

Функции `min()` и `max()` можно применять только к кортежам с одним типом данных. Если кортеж содержит разные типы данных, скажем целое число (`int`) и строку (`str`), то во время выполнения программы произойдет ошибка.
## Вложенные кортежи

Подобно спискам, мы можем создавать вложенные кортежи.

Следующий программный код:

```python
colors = ('red', ('green', 'blue'), 'yellow')
numbers = (1, 2, (4, (6, 7, 8, 9)), 10, 11)
print(colors[1][1])
print(numbers[2][1][3])
```

выводит:

```no-highlight
blue
9
```
## Сравнение кортежей

Кортежи можно сравнивать между собой.

Приведенный ниже код:

```python
print((1, 8) == (1, 8))
print((1, 8) != (1, 10))
print((1, 9) < (1, 2))
print((2, 5) < (6,))
print(('a', 'bc') > ('a', 'de'))
```

выводит:

```no-highlight
True
True
False
True
False
```

Обратите внимание: операции `==` и `!=` применимы к любым кортежам, независимо от типов элементов. А вот операции `<`, `>`, `<=`, `>=` применимы только в том случае, когда соответствующие элементы кортежей имеют один тип.

Приведенный ниже код:

```python
print((7, 5) < ('java', 'python'))
```

выводит:

```no-highlight
TypeError: '<' not supported between instances of 'int' and 'str'
```
## Сортировка кортежей

Как мы помним, списки имеют метод `sort()`, который осуществляет сортировку на месте, то есть меняет порядок исходного списка. Поскольку кортежи по своей природе неизменяемы, то встроенного метода `sort()` они не содержат, тем не менее с помощью встроенной функции `sorted()` (не путать с списочным методом `sort()`) мы можем сортировать значения в кортежах.

Приведенный ниже код:

```python
not_sorted_tuple = (34, 1, 8, 67, 5, 9, 0, 23)
print(not_sorted_tuple)

sorted_tuple = tuple(sorted(not_sorted_tuple))
print(sorted_tuple)
```

выводит:

```no-highlight
(34, 1, 8, 67, 5, 9, 0, 23)
(0, 1, 5, 8, 9, 23, 34, 67)
```
Обратите внимание, что функция `sorted()` возвращает список, но с помощью функции `tuple()` мы приводим результат сортировки к кортежу.
Для сортировки кортежа можно воспользоваться явным преобразованием в список и использовать метод `sort()`: 

```python
not_sorted_tuple = ('cc', 'aa', 'dd', 'bb')
tmp = list(not_sorted_tuple)
tmp.sort()

sorted_tuple = tuple(tmp)
print(sorted_tuple)
```
### Преобразование кортежа в строку и наоборот

**Кортеж можно преобразовать в строку** с помощью строкового метода `join()`.

Приведенный ниже код:

```python
notes = ('Do', 'Re', 'Mi', 'Fa', 'Sol', 'La', 'Si')
string1 = ''.join(notes)
string2 = '.'.join(notes)

print(string1)
print(string2)
```

выводит:

```no-highlight
DoReMiFaSolLaSi
Do.Re.Mi.Fa.Sol.La.Si
```
Обратите внимание, что для применения строкового метода `join()` кортеж должен содержать именно строковые элементы. Если элементы кортежа отличны от строк, то требуется предварительно их преобразовать.
## Упаковка кортежей

**Упаковкой кортежа** называют присваивание его какой-либо переменной.
Обратите внимание на то, что упаковка выполняется всегда, когда справа от знака равенства стоит больше одного значения.

Приведенный ниже код автоматически запакует `1, 2, 3` и `'b',` в кортежи `(1, 2, 3)` и `('b', )` и присвоит их значения переменным `tuple1` и `tuple2`:

```python
tuple1 = 1, 2, 3
tuple2 = 'b',

print(type(tuple1))
print(type(tuple2))
```

выводит:

```1c
<class 'tuple'>
<class 'tuple'>
```
## Распаковка кортежей

Обратная операция, смысл которой в том, чтобы присвоить значения элементов кортежа отдельным переменным, называется **распаковкой кортежа**.

Приведенный ниже код:

```python
colors = ('red', 'green', 'blue', 'cyan')

a, b, c, d = colors

print(a)
print(b)
print(c)
print(d)
```

выводит:

```no-highlight
red
green
blue
cyan
```
Однако, если необходимо получить лишь какие-то отдельные значения, то в качестве "ненужных" переменных позволено использовать символ нижнего подчеркивания `_`.

Приведенный ниже код:

```python
colors = ('red', 'green', 'blue')
a, b, _ = colors

print(a)
print(b)
```

выводит:

```no-highlight
red
green
```
## * при распаковке кортежей

Как мы знаем, если при распаковке кортежа число элементов слева и справа не совпадает, то возникает ошибка времени исполнения. Есть способ собрать сразу **несколько значений в одну переменную**. Это делается при помощи звездочки перед именем переменной.

Рассмотрим программный код:

```python
a, b, *tail = 1, 2, 3, 4, 5, 6
```

В этом случае в переменной `a` будет записана единица, в переменной `b` — двойка, а в переменной `tail` — список, состоящий из всех аргументов, которые не попали в предыдущие переменные. В данном случае `tail` будет равен `[3, 4, 5, 6]`.
Приведенный ниже код:

```python
*names, surname = ('Стефани', 'Джоанн', 'Анджелина', 'Джерманотта')

print(names)
print(surname)
```

выводит:

```no-highlight
['Стефани', 'Джоанн', 'Анджелина']
Джерманотта
```

Аргумент со звездочкой может стоять и посередине.

```python
singer = ('Freddie', 'Bohemian Rhapsody', 'Killer Queen', 'Love of my life', 'Mercury')

name, *songs, surname = singer

print(name)
print(songs)
print(surname)
```

выводит:

```no-highlight
Freddie
['Bohemian Rhapsody', 'Killer Queen', 'Love of my life']
Mercury
```
## Примечания

**Примечание 1.** Если вы хотите распаковать единственное значение в кортеже, после имени переменной должна идти запятая.

Приведенный ниже код:

```python
a = 1,      # не распаковка, а просто присвоение
b, = 1,     # распаковка

print(a)
print(b)
```

выводит:
(1,)
1

Примечание 2.** Распаковывать можно не только кортеж, правая сторона может быть любой последовательностью (кортеж, строка или список).

```python
info = ['timur', 'beegeek.org']
user, domain = info    # распаковка списка

print(user)
print(domain)

a, b, c, d = 'math'    # распаковка строки

print(a)
print(b)
print(c)
print(d)
```
**Примечание 3.** Помимо метода `split()` строковый тип данных содержит метод `partition()`. Метод `partition()` принимает на вход один аргумент `sep`, разделяет строку при первом появлении `sep` и **возвращает кортеж**, состоящий из трех элементов: часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, то кортеж содержит саму строку, за которой следуют две пустые строки.

Приведенный ниже код:

```python
s1 = 'abc-de'.partition('-')
s2 = 'abc-de'.partition('.')
s3 = 'abc-de-fgh'.partition('-')

print(s1)
print(s2)
print(s3)
```

выведет:

```no-highlight
('abc', '-', 'de')
('abc-de', '', '')
('abc', '-', 'de-fgh')
```
**Примечание 4.** С использованием кортежей многие алгоритмы приобретают достаточно краткую форму. Например, вычисление чисел Фибоначчи может выглядеть следующим образом:

```python
n = int(input())
f1, f2 = 1, 1
for i in range(n):
    print(f1)
    f1, f2 = f2, f1 + f2
```

Рассмотрим программный код:

```python
num = 0.1 + 0.1 + 0.1

if num == 0.3:
    print('YES')
else:
    print('NO')
```

Вы будете удивлены, но результатом выполнения такого кода будет `NO`, так как на самом деле в переменной `num` хранится что-то типа 0.30000000000000004.
Из-за ограничений в сохранении точного значения чисел, даже простейшие математические операции могут выдавать ошибочный результат. Поэтому, чтобы сравнивать два `float` числа мы должны использовать такой код:

```python
num = 0.1 + 0.1 + 0.1
eps = 0.000000001           # точность сравнения

if abs(num - 0.3) < eps:    # число num отличается от числа 0.3 менее чем 0.000000001
    print('YES')
else:
    print('NO')
```

Такой код выводит, как полагается, значение `YES`.
## Тип данных Decimal

Тип данных `Decimal` – это класс из стандартного модуля `decimal`. Он представляет собой число с плавающей точкой, как и `float`. Однако, `Decimal` имеет ряд существенных отличий от `float`.

Тип `Decimal` создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство 0.1+0.1+0.1=0.3 было верным.

Тип данных `Decimal` реализован программно, поэтому он в разы медленнее типа данных `float`, реализованного аппаратно. Сам тип данных `Decimal` написан на языке С.

Тип данных `Decimal` оперирует числами с произвольной – задаваемой программистом, но конечной точностью. По умолчанию точность составляет 2828 десятичных знаков.

Тип данных `Decimal` неизменяемый. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.
### Создание Decimal чисел

Создать `Decimal` число можно из обычного целого числа (`int`), из числа с плавающей точкой (`float`) или из строки (`str`).

Приведенный ниже программный код создает `Decimal` числа на основе целого числа и строки:

```python
from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')

print(d1, d2, d3, d4, d5, sep='\n')
```

и выводит:

```no-highlight
1
567
-93
12345
52.198
```
При создании `Decimal` чисел из чисел с плавающей точкой (`float`) возникают проблемы, так как `float` числа округляются внутри до ближайшего возможного, а `Decimal` об этом ничего не знает и копирует содержимое `float`.

Приведенный ниже программный код создает `Decimal` число на основе числа с плавающей точкой:

```python
from decimal import *

num = Decimal(0.1)

print(num)
```

и выводит:

```no-highlight
0.1000000000000000055511151231257827021181583404541015625
```
###  Арифметические операции над Decimal числами

Тип данных `Decimal` отлично интегрирован в язык Python. С `Decimal` числами работают все привычные операции: сложение, вычитание, умножение, деление, возведение в степень.

Можно совершать арифметические операции над `Decimal` и целыми числами (миксовать `Decimal` и `int`), но не рекомендуется смешивать их с `float`.
### Математические функции

`Decimal` числа можно передавать как аргументы функциям, ожидающим `float`. Они будут преобразованы во `float`. К примеру, модуль `math`, оперирующий `float` числами, может работать и с `Decimal` числами.

Приведенный ниже код:

```python
from decimal import *
from math import *

num1 = Decimal('1.44')
num2 = Decimal('0.523')

print(sqrt(num1))
print(sin(num2))
print(log(num1 + num2))
```

выводит:

```no-highlight
1.2
0.4994813555186418
0.6744739152943241
```

Важно понимать, что результатом работы функции модуля `math` являются `float` числа, а не `Decimal`.
![[Pasted image 20231113225116.png]]

Тип данных `Decimal` также содержит полезный метод `as_tuple()` который возвращает кортеж из 33 элементов:

- `sign` – знак числа (00 для положительного числа и 11 для отрицательного числа);
- `digits` – цифры числа;
- `exponent` – значение экспоненты (количество цифр после точки, умноженное на −1−1),

Приведенный ниже код:

```python
from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')

print(num1.as_tuple())
print(num2.as_tuple())
```

выводит:

```no-highlight
DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10)
DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3)
```

Приведенный ниже код:

```python
from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)
```

выводит:

```no-highlight
1
(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7)
-10
```
### Работа с контекстом Decimal чисел

Базовые параметры `Decimal` можно посмотреть в его **контексте**, выполнив функцию `getcontext()`.

Приведенный ниже код:

```python
from decimal import *

print(getcontext())
```

выводит:

```no-highlight
Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, 
flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])
```

Мы видим здесь, что точность 2828 знаков, округление к ближайшему четному, пределы по экспоненте ± 999999± 999999, `capitals` – это про заглавную Е при печати, включенные ловушки – неправильная операция, деление на ноль, переполнение.
### Точность чисел

Контекстом в `Decimal` можно управлять, устанавливая свои значения. Например, чтобы управлять точностью `Decimal`, необходимо изменить параметр контекста `prec` (от англ. precision – точность). При этом точность вступает в силу только во время арифметических операций, а не при создании самих чисел.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 3      # устанавливаем точность в 3 знака

num = Decimal('3.1415')

print(num)
print(num * 1)
print(num * 2)
print(num / 2)
```

выводит:

```no-highlight
3.1415
3.14
6.28
1.57
```
Обратите внимание на то, что точность вступает в силу только во время арифметических операций, а не при создании самих чисел.

### Округление чисел

Округляют числа `Decimal` с помощью метода `quantize()`. Этот метод в качестве первого аргумента принимает объект `Decimal`, указывающий на формат округления.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 4                    # устанавливаем точность числа

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.000')))    #  округление до 3 цифр в дробной части  
print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.0')))      #  округление до 1 цифр в дробной части
```

выводит:

```no-highlight
3.142
3.14
3.1
```

Если точность округления установлена в 22 , а формат округления `Decimal('1.00')`, то возникнет ошибка.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 2                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
```

приводит к возникновению ошибки:

```1c
decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
```

Чтобы избежать ее, необходимо поменять точность округления на 33 и больше.

Помимо первого параметра, метод `quantize()` принимает в качестве второго параметра стратегию округления:

- `ROUND_CEILING` – округление в направлении бесконечности (Infinity);
- `ROUND_FLOOR` – округляет в направлении минус бесконечности (- Infinity);
- `ROUND_DOWN` – округление в направлении нуля;
- `ROUND_HALF_EVEN` – округление до ближайшего четного числа, число 6.56.5 округлится не до 77, а до 66;
- `ROUND_HALF_DOWN` – округление до ближайшего нуля;
- `ROUND_UP` – округление от нуля;
- `ROUND_05UP` – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю).

Приведенный ниже код:

```python
from decimal import *

num = Decimal('3.456')

print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))
```

выводит:

```no-highlight
3.46
3.45
```